/*
  ✅ このコードは「関数式」と「アロー関数」の書き方の違いを示す例である。
  3つとも “数値を1増やす” という意味は同じだが、構文と実行時の性質に差がある。

  React開発ではコールバック（onClick、map、useEffectなど）を大量に書くため、
  - 関数の生成タイミング
  - this の束縛
  - 引数の省略記法
  - return の省略（暗黙return）
  を理解しておくとバグを避けやすい。

  ------------------------------------------------------------
  1) 結果（何が出力される？）
  ------------------------------------------------------------
  いずれも 5 を出力する。

    plusOne(4)  -> 5
    addOne(4)   -> 5
    increment(4)-> 5

  ------------------------------------------------------------
  2) それぞれの定義方法（構文上の違い）
  ------------------------------------------------------------

  (A) 関数式（Function Expression）
      const plusOne = function (n) { return n + 1; }

  - `function (n) { ... }` は “関数オブジェクトを生成する式”
  - その関数を plusOne という const 変数に束縛している
  - 生成された関数は「通常の関数」で、呼び出し形によって this が決まる
    （メソッドとして呼ぶと this が入る、単独呼びなら strict では undefined 等）

  (B) ブロック本体のアロー関数
      const addOne = (n) => { return n + 1; }

  - `=>` を使うアロー関数は “関数オブジェクトを生成する式” という点は同じ
  - ただしアロー関数は **this を自分で持たない（lexical this）**
    ＝外側スコープの this をそのまま使う
  - arguments も自分では持たない（必要なら残余引数 ...args を使う）

  (C) 式本体のアロー関数（最短形）
      const increment = n => n + 1;

  - 引数が1つなら ( ) を省略できる： n => ...
  - 本体が「式」だけなら { } を省略でき、値が **暗黙に return** される
    ＝ `return n + 1;` を書かなくて良い

  ------------------------------------------------------------
  3) アルゴリズム観点：暗黙returnの仕組み
  ------------------------------------------------------------
  `n => n + 1` は “式” を返す短縮形なので、

    n => n + 1
  は概念的に
    n => { return n + 1; }

  と同じ意味になる。

  ただし注意：
  - `{ }` を付けると “ブロック本体” になり、明示 return が必要になる。
    例：n => { n + 1 } は undefined を返す（returnしていない）※よくある事故

  ------------------------------------------------------------
  4) Reactと相性が良い理由（なぜアローが多い？）
  ------------------------------------------------------------
  Reactではコールバックを props で渡したり、イベントハンドラに渡したりする。
  アロー関数は this を持たず外側の this を捕捉するため、
  特に class コンポーネント時代の「this バインド問題」を避けやすかった。

  現在は関数コンポーネントが主流で this を使わない場面が多いが、
  - 短く書ける
  - コールバックを読みやすく書ける
  という理由で依然よく使われる。

  ただし「コンポーネント内で毎回新しい関数が生成される」点は同じなので、
  useMemo/useCallback や memo 化に影響することはある（参照が変わるため）。
  ※今回のコードはトップレベル定義なのでその問題は起きない。
*/

const plusOne = function (n) {
  // ✅ 通常の関数式：function キーワードで関数オブジェクトを作り、変数に束縛する
  return n + 1;
}

const addOne = (n) => {
  // ✅ アロー関数（ブロック本体）：明示 return が必要
  // ✅ this/arguments を自前で持たず、外側の環境を使う（lexical this）
  return n + 1;
};

const increment = n => n + 1;
// ✅ アロー関数（式本体）：暗黙return
// ✅ 1引数なので () も省略可能
// ✅ “最短で読みやすい” 反面、ブロック本体にした瞬間 return を忘れる事故に注意

console.log(plusOne(4));   // 5
console.log(addOne(4));    // 5
console.log(increment(4)); // 5