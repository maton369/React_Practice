/*
  ✅ このコードは「残余引数（rest parameters）」と「配列分割代入（array destructuring）」を
    引数リストで組み合わせた少しトリッキーな例である。

  ポイントは次の2つ：
  - 第1引数は i として受け取る
  - 第2引数以降は “全部まとめて配列” にした上で、その配列の先頭3要素だけを
    j, k, l に分割束縛する（= 残り配列を destructuring する）

  ------------------------------------------------------------
  1) 結果（何が出力される？）
  ------------------------------------------------------------
  (A) sum(1, 2, 3, 4)
      i = 1
      rest = [2, 3, 4]
      [j, k, l] = [2, 3, 4] なので
        j = 2, k = 3, l = 4
      返り値 = 1 + 2 + 3 + 4 = 10

  (B) sum(1, 1, 1, 1, 1, 1)
      i = 1
      rest = [1, 1, 1, 1, 1]
      [j, k, l] = rest の “先頭3つ” だけが束縛されるので
        j = 1, k = 1, l = 1
      余った残り（4つ目以降）はこの関数内では使われず捨てられる
      返り値 = 1 + 1 + 1 + 1 = 4

  よって出力は：
    10
    4

  ------------------------------------------------------------
  2) アルゴリズム観点：引数束縛（parameter binding）の手順
  ------------------------------------------------------------
  `const sum = (i, ...[j, k, l]) => ...` は一見変わっているが、
  概念的には次の順序で束縛が行われる。

  (1) 通常引数 i に第1引数を束縛する
      - i = 1

  (2) 残余引数 ...rest を作る（第2引数以降を配列化）
      - rest = [2, 3, 4] など

  (3) その rest 配列に対して配列分割（destructuring）を適用する
      - [j, k, l] = rest
      - j は rest[0], k は rest[1], l は rest[2] に対応

  つまり、実質的には下の2行を引数リスト内で一度にやっているイメージ：

    const rest = [...(第2引数以降)];
    const [j, k, l] = rest;

  ------------------------------------------------------------
  3) 注意点：引数が足りない場合は undefined になる
  ------------------------------------------------------------
  もし sum(1, 2) のように第2引数以降が不足すると、

    rest = [2]
    [j, k, l] = [2]
      j = 2, k = undefined, l = undefined

  になり、計算結果は NaN になる可能性が高い。
  （数値 + undefined は NaN になりがち）

  そのため実用コードでは、デフォルト値を付けるなどの対策をするのが普通。

  例：
    const sum = (i, ...[j = 0, k = 0, l = 0]) => i + j + k + l;

  ------------------------------------------------------------
  4) 実務上の評価（読みやすさ）
  ------------------------------------------------------------
  この書き方は「できる」けれど、初見だと読み取りが難しい。
  可読性優先なら明示的に書くほうが理解しやすい：

    const sum = (i, ...rest) => {
      const [j, k, l] = rest;
      return i + j + k + l;
    };

  ただし「第2引数以降の先頭3つだけ使う」という意図は、この短縮形でも表現できている。
*/

const sum = (i, ...[j, k, l]) => i + j + k + l;
// ✅ i は第1引数
// ✅ ...[j,k,l] は「第2引数以降を配列化したもの」を [j,k,l] に分割束縛する
//    （= 第2〜第4引数に相当する3つだけ使い、残りは捨てる）

console.log(sum(1, 2, 3, 4));       // 10
console.log(sum(1, 1, 1, 1, 1, 1)); // 4（第5引数以降は無視される）