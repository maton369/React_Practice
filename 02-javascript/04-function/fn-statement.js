/*
  ✅ このコードは「関数宣言（Function Declaration）の巻き上げ」と
    「同名の関数宣言が複数あるときの上書き規則」を確認する例である。

  ------------------------------------------------------------
  1) 結果（何が出力される？）
  ------------------------------------------------------------
  出力は 'bar' になる。

    console.log(fn());  // 'bar'

  理由は、同じスコープに同名の関数宣言が2つある場合、
  “後から出てくる宣言が最終的に有効になる” ためである。

  ------------------------------------------------------------
  2) なぜそうなる？（実行前フェーズ：宣言の収集）
  ------------------------------------------------------------
  JavaScriptエンジンは実行前にスコープを構築し、
  そのスコープ内の「関数宣言」を環境（Environment Record）へ登録する。

  関数宣言は var よりも強く、
  “関数オブジェクト本体ごと” 先に登録される（巻き上げの対象）。

  ここで同名（fn）が2回宣言されているため、
  登録処理は概念的に次のような「上書き」を含む。

  - 1つ目の function fn() { return 'foo'; } を登録
    -> fn は foo を返す関数を指す
  - 2つ目の function fn() { return 'bar'; } を登録
    -> 同名なので上書きされ、fn は bar を返す関数を指す

  つまり、実行が始まる前の時点で fn はすでに「barを返す関数」に確定している。

  ------------------------------------------------------------
  3) 実行フェーズ（上から順に実行するだけ）
  ------------------------------------------------------------
  実行が始まると、先頭行の

    console.log(fn());

  が評価される。この時点で fn は “bar関数” を指しているので 'bar' が出る。

  ※ ここが重要：
     console.log の行はソース上では関数定義より前にあるが、
     関数宣言は準備段階で登録されるため呼び出せる（巻き上げ）。

  ------------------------------------------------------------
  4) 「同名定義の競合」はなぜ危険か
  ------------------------------------------------------------
  アルゴリズム的に見ると、同名の関数宣言が複数あると
  “最終的にどれが有効か” がソースの遠い位置の定義に依存してしまい、
  読み手が追跡しないと正しい挙動を理解できない。

  - 大規模コードや複数ファイル（モジュール）では、特に混乱の原因になる。
  - Reactなどでも同名の関数が別スコープにあるならまだしも、
    同一スコープでの再宣言はバグの温床になりやすい。

  ------------------------------------------------------------
  5) もし関数式（const）で書いたらどうなる？
  ------------------------------------------------------------
  例えば次のようにすると挙動が変わる：

    console.log(fn()); // ReferenceError（TDZ）
    const fn = () => 'foo';
    const fn = () => 'bar'; // そもそも const の再宣言は構文エラー

  - const は初期化前参照ができない（TDZ）
  - 同名再宣言がそもそも禁止される
  ため、こうした “静かに上書きされる” 問題を避けられる。

  その意味で、現代JSでは意図しない上書きを防ぐために
  const/let + 関数式（またはアロー関数）を好むことが多い。
*/

console.log(fn()); // 'bar' が出る（最終宣言が有効）

function fn() {
  return 'foo';
}

function fn() {
  return 'bar';
}