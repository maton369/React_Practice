/*
  ✅ このコードは「var の巻き上げ（hoisting）と初期化タイミング」を確認する典型例である。
  ReactというよりJavaScriptの言語仕様の話だが、React開発でもJSのスコープ/巻き上げ理解は重要。

  ------------------------------------------------------------
  1) 何が起きる？（結論）
  ------------------------------------------------------------
  出力は 100 になる。

  理由：
  `var a;` はスコープ先頭へ “宣言だけ” が巻き上げられる（hoistされる）ため、
  実行開始時点で a は存在している（ただし値は undefined で初期化される）。
  その後 `a = 100;` により代入され、console.log で 100 が出る。

  ------------------------------------------------------------
  2) JavaScriptエンジンの視点（概念的アルゴリズム）
  ------------------------------------------------------------
  実行はざっくり2段階で説明できる：

  (A) 事前処理（宣言の収集 / 環境レコードの構築）
      - そのスコープ内にある var 宣言を集める
      - 変数名を環境（Environment Record）に登録する
      - var は「undefinedで初期化」される

  (B) 実行（上から順にステートメントを評価）
      - 代入・関数呼び出しなどを実行する

  このコードを “エンジンが見る順序” に近づけると、実質こうなるイメージ：

    // (A) まず var 宣言がスコープ先頭にあるものとして扱われる
    var a;      // a は undefined で初期化済み

    // (B) 以降、元の順序で実行される
    a = 100;
    console.log(a); // 100
    // var a; は宣言なので、ここで何も追加の効果はない

  ------------------------------------------------------------
  3) 重要ポイント：var の“巻き上げ”は「宣言」だけ
  ------------------------------------------------------------
  例えば次のような代入を伴う場合でも、
  巻き上げられるのは「var a;」の宣言だけで、代入はその場で実行される。

    console.log(a); // undefined
    var a = 100;    // ここで初めて代入される

  これは “宣言は先に用意されるが、代入は実行順” というルールの結果である。

  ------------------------------------------------------------
  4) let/const との違い（TDZ: Temporal Dead Zone）
  ------------------------------------------------------------
  同じことを let で書くと挙動が変わる：

    a = 100;        // ReferenceError（宣言前に触れない）
    console.log(a);
    let a;

  let/const も “宣言自体は” スコープの開始時点で認識されるが、
  初期化が宣言行に到達するまで行われず、
  それまでの領域（TDZ）では参照すると例外になる。

  ------------------------------------------------------------
  5) 実務上の示唆
  ------------------------------------------------------------
  - var は巻き上げ + 関数スコープのため、意図しない参照が起きやすい。
  - 現代のフロント（React含む）では基本 let/const を使い、
    予測可能なスコープと初期化規則を選ぶのが一般的。
*/

a = 100;
console.log(a);

var a;