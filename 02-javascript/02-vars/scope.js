/*
  ✅ このコードは「var はブロックスコープを持たず、関数スコープである」ことを示す例である。
  ReactというよりJavaScriptの言語仕様の話だが、React開発でもスコープの理解はバグ回避に直結する。

  ------------------------------------------------------------
  1) 結果（何が出力される？）
  ------------------------------------------------------------
  出力は次の順になる：

    50
    50
    100

  理由：
  - if ブロックの中で宣言した var n / var m は、ブロック内ローカルではなく
    “同じスコープ（この場合はグローバルスコープ）” に属する。
  - つまり if 内の var n は “新しい変数” ではなく、外の n を再宣言して上書きしているだけ。
  - m も同様に if の外から参照できる（ブロックを抜けても生きている）。

  ------------------------------------------------------------
  2) どう解釈される？（概念的アルゴリズム：スコープ構築）
  ------------------------------------------------------------
  JavaScriptエンジンは、実行前にざっくり以下を行う：

  (A) 宣言の収集（Environment Recordの構築）
      - 同じスコープ内の var 宣言を集めて “変数名” を登録する
      - var は undefined で初期化される（ただしこの例ではすぐ代入が来る）

  (B) 上から順に実行

  このコードでは var が3つ登場する：
    - var n = 0;
    - if 内の var n = 50;
    - if 内の var m = 100;

  しかし var はブロックスコープではないため、
  if の中の var n と var m も「同じ（グローバル）スコープ」に登録される。

  つまり、エンジン視点ではスコープ上こうなる：

    var n;  // 1つだけ（重複宣言は無視されるが、代入は生きる）
    var m;

  ------------------------------------------------------------
  3) 実行順を“巻き上げを反映した形”に並べると
  ------------------------------------------------------------
  実質的には次のように動くイメージ：

    // (A) 宣言はスコープ先頭にまとめて存在する扱い
    var n;
    var m;

    // (B) 実行
    n = 0;

    if (true) {
      n = 50;       // 「別のn」ではなく、同じnを更新している
      m = 100;      // m もこの時点でグローバル変数として値が入る
      console.log(n); // 50
    }

    console.log(n); // 50（ブロック内で上書き済み）
    console.log(m); // 100（ブロック内で代入済み）

  ------------------------------------------------------------
  4) よくある勘違いポイント
  ------------------------------------------------------------
  - 「if の中で var 宣言したから if の中だけで有効」と思いがちだが、違う。
  - var は “関数スコープ”。
    - 関数の中なら関数内で共有
    - 関数の外ならグローバルで共有
  - そのため、ブロックで変数を分けたい用途には var は不向き。

  ------------------------------------------------------------
  5) let/const に置き換えるとどうなる？
  ------------------------------------------------------------
  let/const は “ブロックスコープ” を持つため、挙動が変わる。

    let n = 0;
    if (true) {
      let n = 50;   // これは別のn（ブロック内だけ）
      let m = 100;  // これもブロック内だけ
      console.log(n); // 50
    }
    console.log(n); // 0（外側のnは変わらない）
    console.log(m); // ReferenceError（mはブロック外に存在しない）

  これが現代JS（React含む）で let/const が推奨される大きな理由の1つである。
*/

var n = 0;

if (true) {
  var n = 50;   // 同一スコープの n を再宣言＋代入（外側の n を上書き）
  var m = 100;  // if の外からも見える（ブロックスコープではない）
  console.log(n); // 50
}

console.log(n); // 50
console.log(m); // 100