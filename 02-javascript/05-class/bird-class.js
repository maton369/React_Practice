/*
  ✅ このコードは JavaScript のクラス構文を使って、
  - インスタンス（new で作る実体）
  - コンストラクタ（初期化手順）
  - インスタンスメソッド（個体の振る舞い）
  - static メソッド（クラスそのものの機能）
  - private フィールド（#で始まる完全非公開データ）
  - 継承（extends / super）
  をまとめて示す例である。

  ------------------------------------------------------------
  1) 全体像（オブジェクト生成とメソッド探索のアルゴリズム）
  ------------------------------------------------------------
  JSのクラスは内部的には “プロトタイプチェーン” に基づく仕組みで動く。

  - `new Bird("ペンギン")` は
    (1) 新しいオブジェクトを作り
    (2) そのオブジェクトの [[Prototype]] を Bird.prototype に設定し
    (3) constructor を this に結びつけて実行し（this.name を設定し）
    (4) 生成したオブジェクトを返す
    というアルゴリズムでインスタンスを生成する。

  - `penguin.introduce()` のようなメソッド呼び出しは
    (1) penguin 自身に introduce があるか探す（通常は無い）
    (2) penguin.__proto__（= Bird.prototype）に introduce があるか探す（ある）
    (3) 見つかった関数を this=penguin の文脈で実行する
    という “プロトタイプチェーン探索” が行われる。

  - 継承（extends）は、この探索経路を
      FlyableBird instance -> FlyableBird.prototype -> Bird.prototype -> Object.prototype
    のように伸ばすことで実現される。

  ------------------------------------------------------------
  2) private フィールド #className の意味
  ------------------------------------------------------------
  `#className` は “クラス外から一切アクセスできない” 本当の非公開フィールド。
  - `this.#className` はクラス内部だけで使える
  - `instance.#className` のようなアクセスは構文エラーになる

  つまり「オブジェクトのプロパティ」ではなく、言語仕様として隠蔽される領域に格納される。
  そのため外部から改変できず、クラスの内部不変条件（invariant）を守りやすい。

  ------------------------------------------------------------
  3) static explain() の意味
  ------------------------------------------------------------
  static メソッドは
  - インスタンスではなくクラス（コンストラクタ関数オブジェクト）にぶら下がる
  - `Bird.explain()` は呼べるが `penguin.explain()` は呼べない
  という性質を持つ。

  アルゴリズム的には、Bird（関数オブジェクト）のプロパティとして登録される。

  ------------------------------------------------------------
  4) extends / super の意味（継承の初期化アルゴリズム）
  ------------------------------------------------------------
  `class FlyableBird extends Bird` は Bird を親クラスとして継承する宣言。

  - サブクラスの constructor では、this を使う前に super(...) を呼ぶ必要がある
    （super が親の初期化ロジックを走らせ、this を確定させるため）

  `super(name)` は
  - 親クラス Bird の constructor を this に対して実行し
  - `this.name = name` をセットする
  という “親初期化” の手続きを行う。

  ------------------------------------------------------------
  5) 実行結果（何が出力されるか）
  ------------------------------------------------------------
  Bird.explain()
    -> "これは鳥のクラスです"

  penguin.introduce()
    -> "私は鳥類のペンギンです"

  hawk.cry("ピィィー")
    -> "タカが「ピィィー」と鳴きました"

  hawk.fly()
    -> "タカが飛びました"
*/

class Bird {
  /*
    ✅ private フィールド（完全非公開）
    ------------------------------------------------------------
    - クラス外からアクセス不可
    - “このクラスの内部状態” を保護するために使う
    - 各インスタンスがそれぞれ #className を持つ（ここでは固定値だが）
  */
  #className = "鳥類";

  constructor(name) {
    /*
      ✅ コンストラクタ（インスタンス初期化）
      ------------------------------------------------------------
      new Bird(name) のときに呼ばれ、this は新しく生成されたインスタンスを指す。

      ここで this.name をセットすることで、
      インスタンス固有の状態（名前）を持たせている。
    */
    this.name = name;
  }

  static explain() {
    /*
      ✅ static メソッド
      ------------------------------------------------------------
      Bird.explain() のようにクラスから直接呼ぶメソッド。
      - インスタンスに属する処理ではなく、「クラス自体の説明」などに向く。
      - this は（呼び出し方によるが）通常 Bird（クラス）を指す。
    */
    console.log("これは鳥のクラスです");
  }

  cry(sound) {
    /*
      ✅ インスタンスメソッド（個体の振る舞い）
      ------------------------------------------------------------
      penguin.cry("...") のようにインスタンスから呼び、
      this はそのインスタンスを指す。

      テンプレート文字列 `${...}` を使ってメッセージを組み立てている。
    */
    console.log(`${this.name}が「${sound}」と鳴きました`);
  }

  introduce() {
    /*
      ✅ private フィールド参照
      ------------------------------------------------------------
      #className はクラス内部でのみ参照可能。
      ここで this.#className としてクラス分類（鳥類）を出力に含める。

      外部から #className を書き換えられないため、
      「私は必ず鳥類である」という内部条件を保ちやすい。
    */
    console.log(`私は${this.#className}の${this.name}です`);
  }
}

class FlyableBird extends Bird {
  constructor(name) {
    /*
      ✅ サブクラスのコンストラクタ
      ------------------------------------------------------------
      extends したクラスは、親の初期化を完了させるために super(...) が必要。

      - super(name) は親（Bird）の constructor を呼び、
        this.name = name を実行してインスタンス状態を整える。
      - super を呼ぶ前に this を使うとエラーになる（this が未確定のため）。
    */
    super(name);
  }

  fly() {
    /*
      ✅ サブクラス独自のメソッド
      ------------------------------------------------------------
      FlyableBird インスタンスにのみ存在する機能。
      メソッド探索（プロトタイプチェーン）により
      - cry/introduce は Bird.prototype から見つかる
      - fly は FlyableBird.prototype から見つかる
      という形で両方が使えるようになる。
    */
    console.log(`${this.name}が飛びました`);
  }
}

/*
  ✅ static メソッド呼び出し（クラスから直接）
*/
Bird.explain();

/*
  ✅ Bird インスタンス生成
  - new によりインスタンスが作られ
  - constructor が走り this.name が設定される
*/
const penguin = new Bird("ペンギン");
penguin.introduce();

/*
  ✅ FlyableBird インスタンス生成（継承）
  - FlyableBird の constructor が呼ばれ
  - super(name) で Bird の constructor が動き this.name が設定される
*/
const hawk = new FlyableBird("タカ");

/*
  ✅ 親クラス由来メソッド（Bird.prototype）を呼べる
*/
hawk.cry("ピィィー");

/*
  ✅ 子クラス独自メソッド（FlyableBird.prototype）を呼べる
*/
hawk.fly();