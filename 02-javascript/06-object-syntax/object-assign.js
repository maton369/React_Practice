/*
  ✅ このコードは `Object.assign` の基本動作を示す例である。
  - 空オブジェクトにコピーして “シャローコピー” を作る
  - 既存オブジェクトに代入して “破壊的に更新（mutate）” する
  - 複数ソースを渡したときは “左から順に上書き” される
  という3点が核心。

  ------------------------------------------------------------
  1) Object.assign(target, ...sources) のアルゴリズム（概念）
  ------------------------------------------------------------
  Object.assign は次のような手順で動く（概念的な説明）：

  (1) target（コピー先）を用意する
  (2) sources を左から順に処理する
  (3) 各 source の “列挙可能な自前プロパティ（enumerable own properties）” を走査し、
      同じキーが target にあれば上書きし、なければ追加する
  (4) 最後に target を返す（新しいオブジェクトを返すとは限らない）

  重要：
  - 返り値は常に target そのもの
  - コピーは “シャローコピー” で、ネストしたオブジェクト参照は共有される

  ------------------------------------------------------------
  2) シャローコピーの作成：Object.assign({}, original)
  ------------------------------------------------------------
*/

const original = { a: 1, b: 2, c: 3 };

const copy = Object.assign({}, original);
/*
  ✅ target に空オブジェクト {} を渡しているため、
  original のプロパティが {} にコピーされ、新しいオブジェクト copy が作られる。

  概念的には：
    const copy = { ...original };
  と同じ目的の “浅いコピー” である。
*/
console.log(copy); // { a:1, b:2, c:3 }（表示形式は環境で多少異なる）

console.log(copy === original);
/*
  ✅ 参照比較（同一オブジェクトか？）
  - copy は新しいオブジェクトなので original とは別参照
  - よって false が出る
*/

 /*
  ------------------------------------------------------------
  3) 破壊的代入：Object.assign(original, ...)
  ------------------------------------------------------------
*/

const assigned = Object.assign(original, { c: 10, d: 50 }, { d: 100 });
/*
  ✅ target が original なので、original 自体が更新される（ミューテーション）。

  ソースは左から順に適用されるので、上書きの流れはこうなる：

  初期：target = original = { a:1, b:2, c:3 }

  source1 = { c:10, d:50 }
    - c は存在するので 3 -> 10 に上書き
    - d は無いので追加（d=50）
    -> { a:1, b:2, c:10, d:50 }

  source2 = { d:100 }
    - d は存在するので 50 -> 100 に上書き
    -> { a:1, b:2, c:10, d:100 }

  返り値 assigned は “target（= original）” そのものを返すため、
  assigned と original は同一参照になる。
*/
console.log(assigned); // { a:1, b:2, c:10, d:100 }

console.log(original);
/*
  ✅ original も同じく更新済みになる（assigned と同じ内容）
  → { a:1, b:2, c:10, d:100 }
*/

 /*
  ------------------------------------------------------------
  4) React的な注意（参考）
  ------------------------------------------------------------
  React では state を直接書き換えるのは避けるのが基本なので、
  Object.assign を使う場合は

    const next = Object.assign({}, prev, { ...updates });

  のように target を新規オブジェクトにして“不変更新”を守るのが安全。
  target に prev/state を渡す（今回の original のように）と破壊的更新になる。
*/