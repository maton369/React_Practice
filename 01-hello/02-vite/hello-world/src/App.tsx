import { useState } from 'react'
/*
  ✅ useState（状態 = state を持つためのHook）
  ------------------------------------------------------------
  React の関数コンポーネントは、基本的に
    props（入力） -> UI（出力）
  を返す「純粋関数」に近い形で書く。

  ただしUIは時間とともに変化する必要があるため、
  “時間変化する値” を React に管理させるのが state であり、
  それを関数コンポーネントに導入する最小の仕組みが useState。

  ■ アルゴリズム観点（React内部の流れ）
  - useState は「このコンポーネントに紐づく状態スロット」を1つ確保する。
  - state の値はレンダリング間で保持される（関数が再実行されても保持される）。
  - setState が呼ばれると、React は更新をスケジュールし、
    次のレンダリングで新しい state を使って UI を再計算する。
*/

import reactLogo from './assets/react.svg'
/*
  ✅ 静的アセットのimport（Viteのビルド機構）
  ------------------------------------------------------------
  TS/JSからSVGを import すると、Vite が
  - 開発中：パス解決して配信
  - ビルド：最適化されたURLへ変換（ハッシュ付きなど）
  してくれる。

  Reactの差分更新アルゴリズムとは直接関係ないが、
  “宣言したUI” の一部として img src に使われる。
*/

import viteLogo from '/vite.svg'
/*
  ✅ / から始まるパス（Viteのpublic/ルート参照）
  ------------------------------------------------------------
  これはプロジェクトのルート（開発サーバのルート）基準で解決される。
  Viteテンプレの「/vite.svg」をそのまま参照する典型例。
*/

import './App.css'
/*
  ✅ コンポーネント用CSSの読み込み
  ------------------------------------------------------------
  ここでの import は「このコンポーネントが必要とする見た目の依存」を明示する役割。
  HMR（Hot Module Replacement）でCSS変更が即座に反映されるのもViteの利点。
*/

function App() {
  /*
    ✅ 関数コンポーネント
    ------------------------------------------------------------
    Reactは <App /> を描画するとき、この App() 関数を呼び出して
    「React Elementツリー（UIの宣言データ）」を得る。

    重要：
    - “関数が呼ばれる = レンダリング” であり、必要に応じて何度も呼ばれる。
    - そのため、レンダリング中に副作用（API呼び出し等）を直接書くと危険。
      副作用は useEffect に閉じ込めるのが基本。
  */

  const [count, setCount] = useState(0)
  /*
    ✅ useState の使い方と意味
    ------------------------------------------------------------
    useState(0) は「初期値0の state スロット」を確保し、
    - count: 現在の状態値
    - setCount: 状態更新関数
    を返す。

    ■ 初回レンダリング
    - count は 0
    - UIは count=0 を反映して構築される

    ■ setCount が呼ばれると…
    - React は「このコンポーネントを再レンダリングする必要がある」と判断し、
      更新をスケジュールする（同期/非同期は状況次第）。
    - 次のレンダリングで count が新しい値になり、UIツリーを再計算する。
    - その後 reconcile（差分計算）→ commit（DOM反映）で最小差分だけ更新する。

    ここが React のコアアルゴリズム：
      “状態が変わる → UIを全部書き換える” のではなく、
      “状態が変わる → UIを再計算 → 差分だけDOM更新” を行う。
  */

  return (
    /*
      ✅ JSX（最終的には createElement の呼び出しに変換される）
      ------------------------------------------------------------
      JSXはあくまで記法であり、内部的には「React Elementの木構造」を作るだけ。

      return された Elementツリーを React が受け取り、
      前回ツリーとの差分を計算してDOMへ反映する。

      <>...</> は Fragment（フラグメント）。
      - 余計な div を増やさずに複数要素を返すための構文。
      - DOMノードを作らず、ツリー上のグルーピングとして扱われる。
    */
    <>
      <div>
        <a href="https://vite.dev" target="_blank">
          {/*
            target="_blank" で新しいタブで開くリンク。

            ※ セキュリティ的には rel="noreferrer" も付けることが推奨されがち。
            （別タブへ移動した際の参照情報や window.opener 周りの安全性）
          */}
          <img src={viteLogo} className="logo" alt="Vite logo" />
          {/*
            img の src に “import したアセットURL” を差し込んでいる。

            Reactのアルゴリズム的には：
            - ここも Elementツリーの一部として扱われる
            - 更新時に src/className が変われば差分としてDOM属性更新が発生する
            今回は固定なので初回にDOM生成されるだけ。
          */}
        </a>

        <a href="https://react.dev" target="_blank">
          <img src={reactLogo} className="logo react" alt="React logo" />
        </a>
      </div>

      <h1>Vite + React</h1>

      <div className="card">
        <button
          /*
            ✅ onClick ハンドラ（イベント → 状態更新 → 再レンダリング）
            ------------------------------------------------------------
            ここが “動的UI” の最小例。

            ユーザークリック → Reactのイベントシステムがハンドラを呼ぶ →
            setCount により状態更新が発生 → Reactが再レンダリングをスケジュール →
            App() が再度呼ばれ、count が新しい値でUI再計算 →
            差分だけDOM反映（ボタンのテキスト部分が更新される）。

            つまり、この1行が React の状態駆動UIのループを起動している。
          */
          onClick={() => setCount((count) => count + 1)}
          /*
            ✅ setCount の引数が「関数」になっている理由
            ------------------------------------------------------------
            setCount(next) は next を新しい状態として採用するが、
            next を関数にすると「直前の状態」を引数で受け取れる。

            setCount(prev => prev + 1) のメリット：
            - 更新が連続して発生しても“最新の状態”から安全に計算できる
            - 非同期的にバッチ処理される状況でも破綻しにくい

            もし setCount(count + 1) と書くと、
            - count は “このレンダリング時点の値” を閉じ込めたものになり、
              連続更新やバッチング次第で意図しない結果になり得る。
            そのため increment のような更新は関数形式が推奨される。
          */
        >
          count is {count}
          {/*
            ✅ JSX内の {count} は「式の埋め込み」
            ------------------------------------------------------------
            ここが state と UI の接続点。
            count が変わると再レンダリングされ、ここが新しい値に置き換わる。

            アルゴリズム的には：
            - 新旧ツリーを比較すると、ここに対応するテキストノードだけが変化
            - commit フェーズでテキストノードの内容だけ更新される
            ＝最小差分更新が発生する。
          */}
        </button>

        <p>
          Edit <code>src/App.tsx</code> and save to test HMR
          {/*
            ✅ HMR（Hot Module Replacement）
            ------------------------------------------------------------
            Vite の開発機能。
            - ソースを保存すると、ページ全体リロードではなく必要部分だけ差し替える。
            - React Fast Refresh により、可能な範囲で state を保ったままUI更新ができる。

            ここは Reactの差分更新とは別の “開発サーバ側の差し替えアルゴリズム”。
            ただし結果として、編集→即反映という体験を実現している。
          */}
        </p>
      </div>

      <p className="read-the-docs">
        Click on the Vite and React logos to learn more
      </p>
    </>
  )
}

export default App
/*
  ✅ export default
  ------------------------------------------------------------
  他ファイル（main.tsx など）から import App できるようにする。
  - ルートで <App /> を描画することで、このコンポーネントを起点にUIツリーが構築される。
*/