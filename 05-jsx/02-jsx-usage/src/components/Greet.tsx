// ✅ このコンポーネントは「name を使って挨拶文を表示する」ことに加えて、
// `times` 回数ぶん同じ挨拶を繰り返し描画する（= UI を複製生成する）ロジックを持つ。
//
// アルゴリズム的な本質は：
// 1) props を受け取り、デフォルト値つきで正規化する（times 未指定なら 1 回）
// 2) 回数 times を “長さ times の配列” に変換する
// 3) その配列を map して、各要素に対応する <p> を生成する
// 4) 生成された ReactElement 群を Fragment でまとめて返す
//
// つまり「回数（整数）→ 要素列（JSX）への写像」を行っているコンポーネントである。

// ------------------------------------------------------------
// 1) Props：このコンポーネントが受け取る入力の型定義
// ------------------------------------------------------------
interface Props {
  name: string;
  times?: number;
  /*
    ✅ times? は optional（省略可能）なプロパティ。
    - 呼び出し側が times を渡さないケースを許容する。
    - その場合の挙動は後段でデフォルト値（=1）により決定する。

    アルゴリズム観点では：
    - 入力ドメインを “name は必須、times は任意” と定義し、
      未指定時の処理を内部で吸収する設計。
  */
}

// ------------------------------------------------------------
// 2) Greet：入力 props から UI を生成する関数コンポーネント
// ------------------------------------------------------------
function Greet(props: Props) {
  // ✅ 分割代入 + デフォルト値で props を正規化
  const { name, times = 1 } = props;
  /*
    ✅ ここが入力正規化のステップ：
    - name は必須なのでそのまま取り出す
    - times は undefined の可能性があるため、
      undefined なら 1 を採用する（times = times ?? 1 と同等）

    つまり内部的には
      timesNormalized = (props.times === undefined) ? 1 : props.times
    のように扱われる。
  */

  // ----------------------------------------------------------
  // 3) UI 生成：times 回の繰り返しで <p> を列挙して返す
  // ----------------------------------------------------------
  return (
    <>
      {/*
        ✅ Fragment：複数の <p> を1つの親要素でまとめる（余計な div を増やさない）
      */}

      {[...Array(times)].map(() => (
        <p>Hello, {name}!</p>
      ))}
      {/*
        ✅ ここが “回数 → 要素列” 変換のコアアルゴリズム。

        3-1) Array(times)
          - 長さ times の配列を作る
          - ただし中身は “空スロット（hole）” の配列になりやすい

        3-2) [...Array(times)]
          - スプレッド構文で配列を展開し、実要素を持つ配列へ変換する
          - これにより map を確実に times 回実行できる形になりやすい

        3-3) .map(() => <p>...</p>)
          - 配列の各要素に対して JSX を生成する
          - 生成されるのは times 個の <p>Hello, {name}!</p>

        ✅ 結果として：
          times = 4 の場合、<p> が4個並ぶ

        ⚠️ 実運用上の重要ポイント（React の差分更新のため）：
        - map で複数要素を返すときは、通常 `key` を付ける必要がある。
          例：.map((_, i) => <p key={i}>...</p>)
        - key がないと React が要素の同一性を追跡しにくくなり、
          警告が出たり、更新時の差分最適化が効きにくくなる。

        ⚠️ もう1点：
        - times が 0 や負数、巨大値の場合の扱いはここでは未定義に近い。
          例：times<=0 なら空表示にする、上限を設ける、などの設計が考えられる。
      */}
    </>
  );
}

// ------------------------------------------------------------
// 4) export：外部から <Greet /> として使えるようにする
// ------------------------------------------------------------
export default Greet;