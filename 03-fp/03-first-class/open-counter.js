// ✅ このコードは「グローバル（モジュール）変数 COUNT を、関数 increment が更新して返す」例である。
// アルゴリズム的には、increment を呼ぶたびに COUNT が 1 増える “カウンタ” を実装している。
//
// 重要ポイント：
// - COUNT は let なので再代入可能（状態を持つ）
// - increment は COUNT を更新する副作用を持つ（純粋関数ではない）
// - `COUNT += 1` は「加算して代入する」複合代入演算子で、更新後の値を返す
// - この設計は簡単だが、状態がグローバルに露出するため、テスト・並行実行・予期せぬ変更に弱い

// ✅ 状態（state）としてのカウンタ
// - 初期値は 0
// - 以後、increment の呼び出し回数に応じて増えていく
let COUNT = 0;

// ✅ increment() のアルゴリズム：読み取り → 更新 → 返却
function increment() {
  /*
    ✅ COUNT += 1 の意味（展開するとこうなる）
      COUNT = COUNT + 1

    実行ステップ（概念）：
    1) 現在の COUNT を読む
    2) 1 を足して新しい値を計算する
    3) COUNT にその新しい値を代入する（状態更新）
    4) 代入後の値（新しい COUNT）を式の値として返す

    つまり increment() の戻り値は「インクリメント後の COUNT」である。

    例：
    - 初期 COUNT=0
    - increment() 1回目：COUNT=1 を返す
    - increment() 2回目：COUNT=2 を返す
    - increment() 3回目：COUNT=3 を返す
    ...
  */
  return (COUNT += 1);
}

/*
  補足（設計観点）：
  - グローバル状態 COUNT に依存すると、どこで増えたか追跡しづらくなる。
  - もし「外から COUNT を直接触らせたくない」なら、
    COUNT を関数スコープに閉じ込めてクロージャで隠蔽する実装（カウンタファクトリ）がよく使われる。
*/