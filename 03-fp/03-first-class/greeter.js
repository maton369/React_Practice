// ✅ このコードは「クロージャ（closure）」の基本例である。
// greeter が内部で関数 sayHello を作って返し、返された関数が
// “外側スコープの変数 target を覚え続ける” ことで、後からでも target を使える。
// つまり「関数を返す関数」であり、かつ「状態（target）を内包した関数オブジェクト」を作っている。

// ------------------------------------------------------------
// 1) greeter(target) の役割：target を束縛した “挨拶関数” を生成して返す
// ------------------------------------------------------------
function greeter(target) {
  /*
    ✅ ここでの target は greeter の引数（ローカル変数）であり、
    greeter の実行中だけ存在する…と思いきや、
    内側の関数が参照している場合は「クロージャ環境」として保持される。
  */

  const sayHello = () => {
    /*
      ✅ sayHello はアロー関数で、呼び出されたときに `target` を参照する。

      ここがクロージャの核心：
      - sayHello は自分の外側（greeter のスコープ）にある `target` を参照している
      - JS の実行モデルでは、関数オブジェクトは
        「関数本体（コード）」だけでなく
        「参照している外側スコープの環境（Environment）」も一緒に持つ
      - そのため greeter の実行が終わっても、
        sayHello が生きている限り `target` は GC されず保持される

      これにより “後から呼んでも target が使える” 状態が実現する。
    */
    console.log(`Hi, ${target}!`);
  };

  /*
    ✅ greeter は sayHello を返す。

    アルゴリズム的には：
    - sayHello 関数オブジェクトを生成する
    - その関数オブジェクトは target を含む外側スコープへの参照を保持する（クロージャ）
    - 呼び出し側へその関数を返す（＝関数を値として返す）
  */
  return sayHello;
}

// ------------------------------------------------------------
// 2) greeter("Step Jun") の評価：target を "Step Jun" に束縛した関数が生成される
// ------------------------------------------------------------
const greet = greeter("Step Jun");
/*
  ✅ ここで起きること：
  - greeter が呼ばれ、target = "Step Jun" が作られる
  - sayHello 関数が作られる（target を参照するクロージャ）
  - sayHello が返され、greet に代入される

  つまり greet は「"Step Jun" を覚えている挨拶関数」になる。
*/

// ------------------------------------------------------------
// 3) greet() の実行：クロージャが保持している target を使ってログを出す
// ------------------------------------------------------------
greet();
/*
  ✅ greet() は sayHello の実行に相当し、
  その内部で target（= "Step Jun"）が参照される。

  出力：
    Hi, Step Jun!
*/

// ------------------------------------------------------------
// まとめ（アルゴリズム観点）
// ------------------------------------------------------------
// - greeter は “関数ファクトリ（関数を生成する関数）”
// - 生成された関数は外側スコープの変数（target）を閉じ込める（closure）
// - その結果、関数は「処理 + 状態」をセットで持つオブジェクトのように振る舞う