// ✅ このコードは「カリー化（currying）的な関数」+「部分適用（partial application）」の例である。
// withMultiple は 2段階で引数を受け取る関数で、
// - 1段階目で n を受け取り
// - 2段階目で m を受け取り
// その積 n*m を返す。
//
// 核心はクロージャ：
// - withMultiple(3) が返す内側関数は、外側引数 n=3 を “環境として保持” する
// - そのため後から呼んでも 3 を覚え続ける（triple の正体）

// ✅ 1段階目：n を受け取って、2段階目（mを受け取る関数）を返す
// - 戻り値は関数 (m) => n * m
// - 内側関数は n を参照するため、n はクロージャとして保持される
const withMultiple = (n) => (m) => n * m;

// ------------------------------------------------------------
// 1) withMultiple(3)(5)：段階的に適用してその場で計算する
// ------------------------------------------------------------
// ✅ 評価手順（概念）
// (1) withMultiple(3) を評価
//     -> n=3 を束縛した関数 f(m) = 3*m が生成される（クロージャ）
// (2) その結果の関数 f に (5) を適用
//     -> f(5) = 3*5 = 15
//
// 出力：15
console.log(withMultiple(3)(5));

// ------------------------------------------------------------
// 2) const triple = withMultiple(3)：部分適用で “3倍関数” を作る
// ------------------------------------------------------------
// ✅ triple は「n=3 を固定した関数」
// - triple(m) は常に 3*m を返す
// - つまり “3倍する関数” を生成して使い回せる
const triple = withMultiple(3);

// ✅ triple(5) は 3*5 = 15
// 出力：15
console.log(triple(5));

// ------------------------------------------------------------
// まとめ（アルゴリズム観点）
// ------------------------------------------------------------
// - withMultiple は「引数を1つずつ受け取る」高階関数で、内部的にはクロージャで状態 n を保持する
// - withMultiple(3)(5) は “その場で生成→即適用”
// - triple = withMultiple(3) は “生成した関数を再利用（部分適用）”
// - どちらも計算自体は O(1) だが、設計としては再利用性・関数合成のしやすさが増す