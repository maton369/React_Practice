// ✅ このコードは「同じ掛け算」を 3 通りのスタイルで表現している。
// 1) 通常の二引数関数（n と m を同時に受け取る）
// 2) 関数を返す関数（クロージャ）で、n を先に固定してから m を受け取る
// 3) (2) をアロー関数でより短く書いたカリー化（currying）的表現
//
// ここでの核心は：
// - (2)(3) は “部分適用（partial application）” を可能にする
// - 内側関数が外側引数 n を保持することで、状態を持つ関数を生成できる（クロージャ）
//
// それぞれのブロックは `{ ... }` で囲われており、変数名が衝突してもスコープが分離される。

// ------------------------------------------------------------
// 1) 通常の手続き的スタイル：二引数の multiply
// ------------------------------------------------------------
{
  // ✅ multiply(n, m) は単純に n*m を返す純粋関数（副作用なし）
  // アルゴリズム：入力2つを受け取り、積を計算して返す（O(1)）
  const multiply = (n, m) => n * m;

  // ✅ そのまま 2 と 4 を渡して 8 を得る
  console.log(multiply(2, 4)); // 8
}

// ------------------------------------------------------------
// 2) クロージャを使う：withMultiple(n) が「n を固定した関数」を返す
// ------------------------------------------------------------
{
  // ✅ withMultiple は “関数ファクトリ（関数を生成する関数）” として振る舞う
  // - まず n を受け取り、
  // - その n を参照する内側関数 (m) => n * m を生成して返す
  //
  // 重要：内側関数は外側スコープの n を参照しているため、
  // - withMultiple の実行が終わっても
  // - 返された関数が生きている限り
  // n は保持される（クロージャ）。
  function withMultiple(n) {
    return (m) => n * m;
  }

  // ✅ withMultiple(2) は「2 を覚えている関数」を返す
  // それに (4) を渡すことで 2*4 が計算される
  //
  // 評価手順（概念）：
  // 1) withMultiple(2) を評価 -> 関数 f(m)=2*m を得る
  // 2) f(4) を評価 -> 8
  console.log(withMultiple(2)(4)); // 8

  // ✅ 実務的にはこう分けて書くと “部分適用” が見えやすい：
  // const times2 = withMultiple(2);
  // console.log(times2(4)); // 8
}

// ------------------------------------------------------------
// 3) アロー関数でカリー化スタイル：withMultiple = n => m => n*m
// ------------------------------------------------------------
{
  // ✅ (2) と全く同じ意味を、アロー関数の “戻り値が関数” という形で短く書いている
  //
  // withMultiple(n) は (m) => n*m を返すので、
  // - withMultiple(2) -> m => 2*m
  // - withMultiple(2)(4) -> 8
  //
  // これが “カリー化（currying）的” な書き方：
  // - 引数を1つずつ受け取り、段階的に関数適用する
  const withMultiple = (n) => (m) => n * m;

  console.log(withMultiple(2)(4)); // 8
}

// ------------------------------------------------------------
// まとめ（アルゴリズム観点）
// ------------------------------------------------------------
// - (1) は一発で計算：multiply(n, m)
// - (2)(3) は段階的に計算：withMultiple(n) が “n を固定した関数” を返し、あとで m を受け取る
// - (2)(3) はクロージャにより「外側の引数 n を保持」するため、部分適用や関数合成と相性が良い