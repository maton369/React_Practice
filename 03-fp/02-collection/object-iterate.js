// ✅ このコードは、オブジェクト `user` に対して
// - Object.keys / Object.values / Object.entries で “列挙可能な自前プロパティ” を配列化し
// - それを使って反復しながら key/value を出力する
// という「オブジェクト → 配列 → 走査」の典型パターンを示している。
//
// 重要ポイント：
// - keys/values/entries はいずれも **新しい配列を生成** する（オブジェクトは非破壊）
// - 対象は “列挙可能（enumerable）な自前（own）プロパティ”
//   （プロトタイプ上のプロパティは含まない）
// - 返る配列の順序は基本的に「プロパティの列挙順（仕様で概ね定義）」に従う
// - map は本来「変換して新配列を作る」用途だが、ここでは副作用（console.log）のために使っている
//   （副作用目的なら forEach の方が意図が伝わりやすい）

const user = {
  id: 3,
  name: 'Bobby Kumanov',
  username: 'bobby',
  email: 'bobby@maple.town',
};

// ------------------------------------------------------------
// 1) Object.keys(user)
// ------------------------------------------------------------
// ✅ keys のアルゴリズム（概念）
// - user の “列挙可能な自前プロパティ名” を収集して配列で返す
// - 返り値は文字列の配列（例：['id','name','username','email']）
console.log(Object.keys(user));

// ------------------------------------------------------------
// 2) Object.values(user)
// ------------------------------------------------------------
// ✅ values のアルゴリズム（概念）
// - keys と同じ順序で “値” だけを収集して配列で返す
// - 返り値は値の配列（例：[3,'Bobby Kumanov','bobby','bobby@maple.town']）
console.log(Object.values(user));

// ------------------------------------------------------------
// 3) Object.entries(user)
// ------------------------------------------------------------
// ✅ entries のアルゴリズム（概念）
// - “[key, value] のペア” を要素に持つ配列を返す
// - 返り値は配列の配列（例：[['id',3],['name','...'], ...]）
console.log(Object.entries(user));

// ------------------------------------------------------------
// 4) Object.keys(user).map(...)
// ------------------------------------------------------------
// ✅ 手順：
// (1) keys(user) でキー配列を作る
// (2) map で各キー k を処理する（ここでは console.log による副作用）
// (3) user[k] で対応する値を取得して表示する
//
// ✅ user[k] の意味（ブラケット記法）
// - k は文字列なので、user.k ではなく user[k] で “動的に” プロパティへアクセスする
//
// ⚠️ map は戻り値を集めて新配列を返すが、ここでは返り値を使っていない
// → 副作用が目的なら forEach の方が一般に自然
Object.keys(user).map((k) => {
  console.log(k, user[k]);
});

// ------------------------------------------------------------
// 5) Object.entries(user).map(([k, v]) => ...)
// ------------------------------------------------------------
// ✅ entries の結果は [key, value] のペア配列なので、
// 分割代入で ([k, v]) として受け取れる。
//
// - k はキー（文字列）
// - v は値
//
// こちらは user[k] を再参照しなくても v を直接使えるので、
// キーと値を同時に扱うときは keys より entries の方が楽なことが多い。
Object.entries(user).map(([k, v]) => {
  console.log(k, v);
});

// ------------------------------------------------------------
// まとめ（アルゴリズム観点）
// ------------------------------------------------------------
// - keys/values/entries は「オブジェクトの列挙可能プロパティを配列化」する O(N) の収集処理
// - その後 map（または forEach/for...of）で配列を走査して O(N) の処理をする
// - つまり全体としては「収集 O(N) + 走査 O(N)」の2段階パイプラインになっている