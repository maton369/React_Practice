// ✅ このコードは、配列 `arr` に対して
// - reduce（畳み込み / 集約）
// - sort（並び替え）
// を実行し、結果を console.log で表示する例である。
//
// 重要ポイント：
// - reduce は “左から順に走査して累積値を更新する” 集約アルゴリズム（基本 O(N)）
// - sort は “配列を破壊的に並び替える” アルゴリズムで、比較関数に従って順序を決める
//   （実装の詳細なソート方式は環境依存だが、一般に計算量は O(N log N)）
// - そしてこのコードは **同じ配列 arr に対して reduce の後に sort を呼ぶ** ため、
//   sort の副作用（arr の並び替え）が発生する点が重要である
//   （ただし reduce は非破壊なので、reduce の結果自体には影響しない）
const arr = [1, 2, 3, 4, 5];

console.log(
  // ------------------------------------------------------------
  // 1) arr.reduce((n, m) => n + m)
  // ------------------------------------------------------------
  // ✅ reduce のアルゴリズム（畳み込み / fold）
  // - 配列を左から順に走査する
  // - “累積値 accumulator” と “現在要素 current” を引数にコールバックを呼び、
  //   その返り値を次の累積値として更新していく
  //
  // ここでは (n, m) => n + m なので「合計」を求める畳み込みになる。
  //
  // ⚠️ 初期値を渡していない場合の規則：
  // - 最初の要素 arr[0] が累積値（accumulator）として採用される
  // - 走査は arr[1] から始まる
  //
  // この arr の場合：
  // - 初期 accumulator = 1
  // - 次の要素 2 を足す → 3
  // - 次の要素 3 を足す → 6
  // - 次の要素 4 を足す → 10
  // - 次の要素 5 を足す → 15
  //
  // 出力：15
  arr.reduce((n, m) => n + m),

  // ------------------------------------------------------------
  // 2) arr.sort((n, m) => n > m ? -1 : 1)
  // ------------------------------------------------------------
  // ✅ sort のアルゴリズム（比較関数に基づく並び替え）
  // - sort は配列を “破壊的に” 並び替える（元の arr が変わる）
  // - 比較関数 comparator(a, b) の返り値で並び順を決める
  //
  // 一般的な約束（比較関数の返り値の意味）：
  // - comparator(a, b) < 0 なら a を b より前に置く
  // - comparator(a, b) > 0 なら a を b より後ろに置く
  // - comparator(a, b) = 0 なら順序は同等（入れ替えなくてよい）
  //
  // 今回の comparator は：
  //   (n, m) => (n > m ? -1 : 1)
  //
  // これは「n が m より大きいなら n を前へ（-1）」にしたい、という意図なので
  // “降順（大きい順）” に並べたい比較関数になっている。
  //
  // ✅ この配列なら最終的に：
  //   [5, 4, 3, 2, 1]
  //
  // ⚠️ 注意（比較関数の落とし穴）：
  // - n と m が等しい場合でも 1 を返す（0 を返さない）ので、
  //   “同値” の扱いが厳密ではない（重複要素があると順序の安定性や期待が崩れ得る）
  // - 数値の降順なら一般に `m - n` のように書くと等値で 0 が自然に出る
  //
  // とはいえ、この arr は重複なしなので見た目の結果は問題になりにくい。
  arr.sort((n, m) => (n > m ? -1 : 1)),
);

// ✅ まとめ：この入力では概ね次の2つが表示される
// - reduce の結果：15
// - sort の結果  ：[5, 4, 3, 2, 1]
//
// なお、sort は arr を破壊的に変更しているため、以後 arr を参照すると並び替え後の状態になっている。