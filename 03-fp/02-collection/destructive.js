// ✅ このコードは `Array.prototype.sort` が
// - 配列を **破壊的（in-place）** に並び替える
// - 返り値として **並び替え後の配列（= 元配列そのもの）** を返す
// という性質を確認するための例である。
//
// さらに、比較関数 `(n, m) => (n < m ? -1 : 1)` によって
// “昇順（小さい順）” に並べ替える意図を表している。

const arr = [4, 8, 2, 6];

// ------------------------------------------------------------
// 1) sort のアルゴリズム（概念）：比較関数で順序を決めて in-place で並べ替える
// ------------------------------------------------------------
//
// arr.sort(comparator)
//
// - comparator(a, b) < 0 なら a を b より前に置く
// - comparator(a, b) > 0 なら a を b より後ろに置く
// - comparator(a, b) = 0 なら同等（入れ替え不要）
//
// sort は実装により詳細は異なるが、一般に
// - 要素同士を comparator で比較しながら並び替える
// - 計算量は概ね O(N log N)
// という比較ベースのソートを行う。
// ただし一番重要なのは「元配列を直接書き換える」点である。

console.log(
  // ------------------------------------------------------------
  // 2) comparator の意味：n < m なら n を前へ（昇順）
// ------------------------------------------------------------
  arr.sort((n, m) => (n < m ? -1 : 1)),
  /*
    ✅ この comparator は次のルールを表す：
    - n < m なら n を m より前に置く（-1 を返す）
    - それ以外（n >= m）なら n を m より後ろに置く（1 を返す）

    直感的には「小さい方を前へ」なので昇順になる。

    ⚠️ 注意（等値ケース）：
    - n === m の場合も 1 を返す（0 を返さない）
    - 重複要素がある配列だと “同値” の扱いが不自然になり得る
      （安定性や期待する順序が崩れる可能性）
    - 数値昇順なら通常 `n - m` と書くと、等値で 0 が自然に出て安全寄り
    ただし今回の配列は重複が無いので結果は素直に昇順になる。
  */

  // ------------------------------------------------------------
  // 3) arr をそのまま出力：sort が in-place であることの確認
  // ------------------------------------------------------------
  arr,
  /*
    ✅ ここがこの例の核心：
    - sort の返り値は “並べ替え後の配列” だが、それは arr 自身
    - つまり `arr.sort(...)` を実行した時点で arr の中身が変わっている

    したがって、console.log の第1引数（sort結果）と第2引数（arr）は
    **同じ並び** で表示される。

    この入力では最終的に arr は [2, 4, 6, 8] になる。
  */
);

// ✅ まとめ：出力は概ね次のようになる（表示形式は環境差あり）
// [2, 4, 6, 8] [2, 4, 6, 8]