// ✅ このコードは、同じ配列 `arr` を走査して
// - 偶数だけを表示する（forEach）
// - 奇数だけを表示する（for...of）
// という2パターンを対比している。
//
// どちらも本質は「配列を左から右へ1回ずつ走査する線形アルゴリズム（O(N)）」であり、
// 違いは “書き方” と “制御のしやすさ（break/continue/return 等）” にある。

const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];

// ------------------------------------------------------------
// 1) arr.forEach(...)：コールバックを各要素に適用する走査
// ------------------------------------------------------------
//
// ✅ forEach のアルゴリズム（概念）
// - 配列のインデックス 0..length-1 を順に走査する
// - 各要素 n についてコールバック関数を呼ぶ
// - 戻り値は使わない（forEach 自体も undefined を返す）
// - 主目的は「副作用（ここでは console.log）を起こすこと」
//
// ⚠️ 制御フローの性質
// - forEach の外側から break で止めることはできない
// - continue もできない（コールバック内で条件分岐することになる）
// - return は “コールバック関数から戻る” だけで、forEach 全体を止めるわけではない
//
// つまり「最後まで走り切る走査」として使うのが基本である。

arr.forEach((n) => {
  // ✅ 偶数判定アルゴリズム（剰余）
  // - n % 2 は 2 で割った余り
  // - 余りが 0 なら偶数
  if (n % 2 === 0) {
    // ✅ 条件を満たすときだけ副作用（ログ出力）を起こす
    console.log(`${n} is even`);
  }
});

// この forEach ブロックの出力は以下（配列が1..9なので偶数は 2,4,6,8）
// 2 is even
// 4 is even
// 6 is even
// 8 is even

// ------------------------------------------------------------
// 2) for...of：イテレータに基づく走査（ループ構文）
// ------------------------------------------------------------
//
// ✅ for...of のアルゴリズム（概念）
// - 配列のイテレータから要素を1つずつ取り出して n に束縛する
// - その都度ループ本体を実行する
//
// ✅ forEach と比べたときの強み
// - break で途中終了できる
// - continue で次の反復へ飛ばせる
// - 例外処理や await などと合わせた制御も素直に書ける
//
// そのため「走査しつつ制御したい」場面では for...of が扱いやすい。

for (let n of arr) {
  // ✅ 奇数判定アルゴリズム（剰余）
  // - n % 2 が 0 でないなら奇数
  if (n % 2 !== 0) {
    console.log(`${n} is odd`);
  }
}

// この for...of ブロックの出力は以下（奇数は 1,3,5,7,9）
// 1 is odd
// 3 is odd
// 5 is odd
// 7 is odd
// 9 is odd

// ------------------------------------------------------------
// まとめ（アルゴリズム観点）
// ------------------------------------------------------------
// - 両者とも線形走査（O(N)）で、要素ごとに剰余判定（O(1)）を行っている
// - forEach は「最後まで走り切る副作用処理」に向く
// - for...of は「途中終了やスキップなど制御が必要な走査」に向く