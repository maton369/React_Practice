// ✅ このコードは「元配列を壊さずに（不変に保ったまま）並べ替え・反転した新配列を作る」例である。
// sort と reverse はどちらも **破壊的（in-place）** なメソッドなので、
// 直接 `list.sort(...)` や `list.reverse()` をすると list 自体が書き換わってしまう。
// そこで、先にコピーを作ってから操作することで “元を保持” している。
// （React の state 更新など、不変性が重要な場面で頻出のパターン）

const list = [4, 8, 2, 6];

// ------------------------------------------------------------
// 1) sortedList：slice() でコピー → sort() で並べ替え
// ------------------------------------------------------------
//
// ✅ list.slice() のアルゴリズム（シャローコピー）
// - slice() は引数なしだと [0..length) を切り出すので、実質「全要素コピー」になる
// - 新しい配列インスタンスを返す（list とは別参照）
// - 要素がプリミティブなら値がコピーされるが、要素がオブジェクトなら参照は共有（シャロー）
//
// つまり
//   const copy = list.slice();
// は
//   copy !== list
// を保証し、以降の破壊的操作を copy に閉じ込められる。

// ✅ sort() のアルゴリズム（比較関数に基づく in-place ソート）
// - sort は配列を **破壊的に並べ替え**、返り値として “並べ替え後の配列（= 自分自身）” を返す
// - comparator(a,b) の返り値で順序を決める（負: a を前、正: a を後）
// - 計算量は一般に O(N log N)（詳細は実装依存）

const sortedList = list
  .slice() // ✅ 元 list を保持するために先にコピーを作る（ここで参照分離）
  .sort((n, m) => (n < m ? -1 : 1));
/*
  comparator の意味：
  - n < m なら n を前へ（昇順）
  - それ以外（n >= m）なら n を後ろへ

  ⚠️ 等値で 0 を返さない点は注意（重複があると不自然になり得る）。
  数値昇順なら一般に `n - m` の方が等値で 0 になり安全寄り。
  ただし今回 list は重複が無いので結果は素直に昇順になる。

  結果：
  - sortedList は [2, 4, 6, 8]
  - list は元の [4, 8, 2, 6] のまま（コピーに対して sort しているため）
*/
console.log(sortedList, list);

// ------------------------------------------------------------
// 2) reverseList：スプレッドでコピー → reverse() で反転
// ------------------------------------------------------------
//
// ✅ [...list] のアルゴリズム（シャローコピー）
// - イテレータ（配列要素列）を展開して新配列を作る
// - list とは別参照の配列になる（シャロー）

// ✅ reverse() のアルゴリズム（in-place 反転）
// - reverse は配列を **破壊的に** 反転する
// - 典型的には両端から要素を入れ替える（swap）を繰り返す
//   例：left=0, right=len-1 を交換し、内側へ寄せる
// - 計算量は O(N)

const reverseList = [...list].reverse();
/*
  結果：
  - reverseList は [6, 2, 8, 4]
  - list は元の [4, 8, 2, 6] のまま（コピーに対して reverse しているため）
*/
console.log(reverseList, list);

// ------------------------------------------------------------
// まとめ：このコードで確認できること
// ------------------------------------------------------------
// - sort / reverse は破壊的なので、そのまま使うと元配列が変わる
// - 先にコピー（slice / spread）を作れば、破壊的操作をコピー側に閉じ込められる
// - 不変性が必要な場面では「コピーしてから操作」が基本戦略になる