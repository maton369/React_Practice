// 手続き型プログラミング（Imperative / Procedural）
// - 「結果を貯める箱（配列）」を用意し、ループで状態を更新（push）しながら結果を作る。
// - アルゴリズムは「走査 → 条件判定 → 収集」という流れで、状態（octuples）が育っていく。
{
  const octuples = []; // ✅ 結果を蓄積する配列（状態）

  // ✅ 1〜100 を順に走査する反復アルゴリズム
  // - n を 1 から開始し、100 まで 1 ずつ増やしながらチェックする
  for (let n = 1; n <= 100; n += 1) {
    // ✅ 倍数判定アルゴリズム：剰余（mod）を使う
    // - n % 8 は「n を 8 で割った余り」
    // - 余りが 0 なら 8 の倍数（8, 16, 24, ...）
    if (n % 8 === 0) {
      // ✅ 条件を満たした値だけ結果配列へ追加（破壊的更新）
      octuples.push(n);
    }
  }

  // ✅ 出力例：[8, 16, 24, ..., 96]
  console.log(octuples);
}

// 関数型プログラミング（Functional / Declarative）
// - 「データを作る → データを絞る」という変換パイプラインで表現する。
// - 中間配列は生成されるが、目的（何をしたいか）が式として読みやすくなることが多い。
{
  // ✅ range(start, end) は [start, end)（end は含まない半開区間）を生成する
  // 例：range(1, 101) -> [1, 2, 3, ..., 100]
  const range = (start, end) =>
    // new Array(end - start) で長さ分の配列を作り、
    // .keys() で 0..length-1 のインデックス列を取り、
    // [... ] で配列化して、
    // map で start を足して start..end-1 にずらす。
    [...new Array(end - start).keys()].map((n) => n + start);

  // ✅ 変換パイプライン：
  // 1) range(1, 101) で 1..100 を生成
  // 2) filter で 8 の倍数だけ残す（元配列は変更せず新配列を返す）
  const octuples = range(1, 101).filter((n) => n % 8 === 0);

  console.log(octuples); // ✅ 出力例：[8, 16, 24, ..., 96]
}