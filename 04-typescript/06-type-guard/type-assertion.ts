// ✅ このコードは「JSON.parse の結果は信頼できない（unknown）ので、型アサーション（as）で強引に User 扱いし、
// その結果として実行時エラーが起き得る」という “型安全と実行時安全のズレ” を示す例である。
//
// 重要ポイント：
// - JSON.parse の戻り値は実行時には何でもあり得る（string/number/object/配列/null...）
// - ここでは data: unknown として “いったん分からない” と扱っているのは良い
// - しかし `data as User` は「検証せずに User だと決め打ちする」操作であり、実行時の形は変わらない
// - そのため、User が要求する `address.town` が実際に存在しない場合、実行時に落ちる
//
// アルゴリズム的には：
// 1) 文字列 JSON を parse して “何らかの値” を得る
// 2) その値を検証せずに User とみなす（型だけ変える）
// 3) User の想定構造に基づいて深いプロパティ参照を行う
// 4) 想定構造が無ければ undefined 参照で例外が発生する

{
    // ------------------------------------------------------------
    // 1) User：期待するデータ構造（型の契約）
    // ------------------------------------------------------------
    interface User {
        // ✅ username は文字列
        username: string;

        // ✅ address はオブジェクトで、zipcode と town を持つ想定
        address: { zipcode: string; town: string };
    }

    // ------------------------------------------------------------
    // 2) str：入力 JSON（ただし User の形とは一致していない）
    // ------------------------------------------------------------
    const str = `{ "username": "patty", "town": "Maple Town" }`;
    /*
      ⚠️ この JSON の実体：
        { username: "patty", town: "Maple Town" }
  
      User が期待する形：
        {
          username: string,
          address: { zipcode: string, town: string }
        }
  
      差分：
      - address が無い
      - town がトップレベルにある（本来は address の中にある想定）
    */

    // ------------------------------------------------------------
    // 3) JSON.parse：実行時に “何らかの値” を生成する（型は信用できない）
    // ------------------------------------------------------------
    const data: unknown = JSON.parse(str);
    /*
      ✅ unknown にしている点は良い：
      - 以後、適切な検証をしないとプロパティ参照ができないように強制できる
  
      ただし、unknown は「分からない」だけであって、
      data の中身が User である保証はどこにもない。
    */

    // ------------------------------------------------------------
    // 4) 型アサーション：検証なしで User とみなす（危険）
    // ------------------------------------------------------------
    const user = data as User;
    /*
      ⚠️ `as User` の意味：
      - “コンパイラに対して User だと信じてくれ” と伝えるだけ
      - 実行時の data の形は一切変わらない（address が生えるわけではない）
  
      つまりここで安全性は “見かけ上” 回復するが、実体は不整合のまま。
    */

    // ------------------------------------------------------------
    // 5) 深いプロパティ参照：想定が外れると実行時例外になる
    // ------------------------------------------------------------
    console.log(user.address.town);
    /*
      この行で起きること（実行時）：
      - user.address は存在しない（undefined）
      - undefined.town を読もうとして TypeError になる
  
      ✅ コンパイルは通る理由：
      - `as User` により “address は必ずある” と型が言っているから
      - しかしそれは検証ではなく、単なる宣言（決め打ち）
  
      ここが「静的型（TypeScript）と実行時実体（JavaScript）のズレ」の典型である。
    */
}