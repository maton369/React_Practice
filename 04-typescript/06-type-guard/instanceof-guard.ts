// ✅ このコードは TypeScript/JavaScript における
// - クラス継承（Base を共通基底として Foo/Bar が派生）
// - union 型（Foo | Bar）
// - instanceof によるランタイム型ガード（絞り込み / narrowing）
// を組み合わせて、引数の具体型に応じて分岐する例である。
//
// アルゴリズム的には：
// 1) 入力は Foo または Bar のどちらか（union）として受け取る
// 2) arg instanceof Foo を実行時に評価する
// 3) true なら arg は Foo とみなして Foo 専用メソッド foo() を呼ぶ
// 4) false なら arg は Bar とみなして Bar 専用メソッド bar() を呼ぶ
// 5) その後、どちらにも共通な Base のプロパティ common は分岐外でも安全に使える

// ------------------------------------------------------------
// 1) Base：共通の基底クラス（両者が必ず持つ共通要素）
// ------------------------------------------------------------
class Base {
    // ✅ Foo/Bar どちらのインスタンスにも存在する共通プロパティ
    common = "common";
}

// ------------------------------------------------------------
// 2) Foo：Base を継承し、foo() を追加する派生クラス
// ------------------------------------------------------------
class Foo extends Base {
    // ✅ Foo にしか存在しない振る舞い
    foo() { console.log("foo"); }
}

// ------------------------------------------------------------
// 3) Bar：Base を継承し、bar() を追加する派生クラス
// ------------------------------------------------------------
class Bar extends Base {
    // ✅ Bar にしか存在しない振る舞い
    bar() { console.log("bar"); }
}

// ------------------------------------------------------------
// 4) doDivide：Foo | Bar を受け取り、型ガードで分岐して処理する
// ------------------------------------------------------------
const doDivide = (arg: Foo | Bar) => {
    /*
      ✅ 引数 arg の型は Foo | Bar（どっちか分からない）。
      したがってこの時点では
      - arg.foo() も
      - arg.bar() も
      「存在する保証がない」ため、そのまま呼ぶのは危険。
  
      ここで instanceof によって “実行時の実体” を調べて、
      安全に呼べる側へ絞り込む。
    */

    // ----------------------------------------------------------
    // 4-1) instanceof Foo：arg が Foo のインスタンスかどうか判定する
    // ----------------------------------------------------------
    if (arg instanceof Foo) {
        /*
          ✅ このブロック内では TypeScript が arg の型を Foo に絞り込む。
          そのため Foo 専用の foo() が安全に呼べる。
        */
        arg.foo();

        // arg.bar();
        /*
          ❌ これは型エラー（コメントアウトされている通り）：
          - この分岐内で arg は Foo と確定している
          - Foo には bar() が無い
          → “無いメソッドを呼ぶな” とコンパイラが止める
        */
    } else {
        /*
          ✅ ここに来た時点で arg instanceof Foo が false なので、
          arg は Bar だとみなせる（union の残りが Bar だけ）。
          TypeScript も arg を Bar に絞り込む。
        */
        arg.bar();

        // arg.foo();
        /*
          ❌ こちらも型エラー：
          - この分岐内で arg は Bar と確定
          - Bar には foo() が無い
        */
    }

    // ----------------------------------------------------------
    // 4-2) 共通部分の利用：Base の common は分岐外でも安全
    // ----------------------------------------------------------
    console.log(arg.common);
    /*
      ✅ ここが “共通基底” の効きどころ：
      - Foo も Bar も Base を継承している
      - つまり arg が Foo でも Bar でも common は必ず存在する
      - そのため分岐の外（arg が Foo/Bar の union に戻った場所）でも参照できる
  
      アルゴリズム的には：
      - “型ごとの処理” は分岐内に閉じ込め、
      - “共通処理” は分岐外にまとめる
      という構造になっている。
    */
};

// ------------------------------------------------------------
// 5) 動作確認：Foo と Bar を渡して分岐が切り替わる
// ------------------------------------------------------------
doDivide(new Foo()); // instanceof Foo が true → foo() → common
doDivide(new Bar()); // instanceof Foo が false → bar() → common