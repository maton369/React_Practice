// ✅ このコードは TypeScript のユーティリティ型 `Record<K, V>` を使って、
// 「特定のキー集合（Animal）を必ず全て持つ辞書型（AnimalNote）」を定義し、
// その辞書を実際に作ってログ出力する例である。
//
// 重要ポイント：
// - Animal は 'cat'|'dog'|'rabbit' の有限集合（文字列リテラル union）
// - Record<Animal, string> は
//   “キーが Animal の各要素、値が string” のオブジェクト型を生成する
// - その結果、animalKanji は cat/dog/rabbit を全て必須で持つ必要がある
//   （1つでも欠けると型エラーになる）
// - コメントにある mapped type `{ [key in Animal]: string }` と Record はほぼ同義

// ------------------------------------------------------------
// 1) Animal：キー集合（有限集合）
// ------------------------------------------------------------
type Animal = 'cat' | 'dog' | 'rabbit';
/*
  ✅ Animal は集合で言えば { 'cat', 'dog', 'rabbit' }。
  以後、辞書のキー空間をこの集合に固定するために使う。
*/

// ------------------------------------------------------------
// 2) AnimalNote：Animal をキーにし、値を string にする辞書型
// ------------------------------------------------------------
type AnimalNote = Record<Animal, string>;
// type AnimalNote = { [key in Animal]: string }
/*
  ✅ Record<K, V> の意味（アルゴリズム）：
  - K の各要素をキーとして必ず持ち、
  - 各キーの値は V 型である
  というオブジェクト型を生成する。

  Record は内部的には mapped type と同じ発想で、
    { [key in Animal]: string }
  という “キー集合に対する一括マッピング” を短く書ける。
*/

// ------------------------------------------------------------
// 3) 実体：英語キー → 漢字表記 の対応表を作る
// ------------------------------------------------------------
const animalKanji: AnimalNote = {
    // ✅ cat/dog/rabbit の3キーが必須
    cat: '猫',
    dog: '犬',
    rabbit: '兎',
};
/*
  ✅ 型チェック観点：
  - 3キーすべてが揃っているので OK
  - 値はすべて string なので OK

  もし rabbit を書き忘れると、AnimalNote の要件を満たさず型エラーになる。
  逆に、例えば fox: '狐' を足すと、余計なキーとして型エラーになり得る
  （余剰プロパティチェックの文脈で）。
*/

// ------------------------------------------------------------
// 4) 出力：実行時には普通の JS オブジェクト
// ------------------------------------------------------------
console.log(animalKanji);
/*
  ✅ 実行時は単なるオブジェクトとして表示される。
  Record の効果はコンパイル時に「キーが揃っているか」を保証する点にある。
*/