// ✅ このコードは TypeScript の型レベルユーティリティとしてよく使う
// 「ValueOf（オブジェクトの値の union 型を取り出す）」を定義し、
// それを permissions の値型抽出に適用する例である。
//
// 重要ポイント：
// - `as const` により permissions の値が number ではなく “数値リテラル型” に固定される
// - `keyof T` はオブジェクト型 T のキー集合を union として取り出す
// - `T[keyof T]` は「T の全キーでインデックスアクセスした結果」
//   → すなわち “T の値の union 型” になる
//
// アルゴリズム的には：
// - 定数テーブル（permissions）から “許される値集合” を自動導出し、
//   手書き union（1|2|4）を不要にする設計である。

// ------------------------------------------------------------
// 1) permissions：権限文字 → ビット値 の定数テーブル
// ------------------------------------------------------------
const permissions = {
    // 0b100 = 4
    r: 0b100,

    // 0b010 = 2
    w: 0b010,

    // 0b001 = 1
    x: 0b001,
} as const;
/*
  ✅ `as const` の効果：
  - プロパティ値が “ただの number” に広がらず、
    r: 4, w: 2, x: 1 のような “リテラル型” になる
  - その結果、後で値を union として取り出すと
      4 | 2 | 1
    のように有限集合として扱える
*/

// ------------------------------------------------------------
// 2) ValueOf<T>：オブジェクトの「値型の union」を取り出す型ユーティリティ
// ------------------------------------------------------------
type ValueOf<T> = T[keyof T];
/*
  ✅ ここが型レベルの核心：

  - keyof T
    => T のキー名集合（例：'r' | 'w' | 'x'）

  - T[keyof T]
    => T を “全キー union” でインデックスアクセスした型
       例：T['r'|'w'|'x'] = T['r'] | T['w'] | T['x']

  よって ValueOf<T> は「T の全プロパティ値の union 型」になる。

  これは “辞書（レコード）から値の集合を抽出する” 汎用操作であり、
  permissions のような定数マップの値型抽出に頻出する。
*/

// ------------------------------------------------------------
// 3) PermNum：permissions の値集合（1 | 2 | 4）を自動導出
// ------------------------------------------------------------
type PermNum = ValueOf<typeof permissions>;   // 1 | 2 | 4
/*
  評価の流れ（概念）：

  - typeof permissions
    => { readonly r: 4; readonly w: 2; readonly x: 1 }

  - keyof typeof permissions
    => 'r' | 'w' | 'x'

  - (typeof permissions)[keyof typeof permissions]
    => 4 | 2 | 1

  したがって PermNum は 1 | 2 | 4（順序は union なので意味は同じ）になる。

  ✅ これにより
    type PermNum = 1 | 2 | 4;
  を手で書かずに済み、テーブル変更にも型が追従する。
*/