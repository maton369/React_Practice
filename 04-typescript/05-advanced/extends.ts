// ✅ このコードは TypeScript のジェネリクスと intersection 型（&）を使って、
// 「2つのオブジェクトをスプレッドでマージし、型としては両方のプロパティを持つ」
// という関数 overMerge を定義している例である。
//
// 重要ポイント：
// - <T, U extends T> により、obj2 は obj1 と少なくとも同じ形状（T を満たす）であることを要求する
//   → つまり obj2 は obj1 が持つ必須プロパティを欠かせない（“上位互換” の関係）
// - 返り値の型 T & U は「T の要件と U の要件を両方満たす」型（AND 合成）
// - 実装は { ...obj1, ...obj2 } で、後勝ちルールによりキーが衝突したら obj2 の値が優先される
//
// ⚠️ 注意：型レベルの `T & U` は “両方を満たす” という静的契約だが、
// 実行時のスプレッドは「同名キーは後の値で上書き」という動作なので、
// “両方の値が共存する” わけではない点に注意（キーが衝突した場合）。

// ------------------------------------------------------------
// 1) overMerge：obj1 と obj2 をマージするジェネリック関数
// ------------------------------------------------------------
const overMerge = <T, U extends T>(obj1: T, obj2: U): T & U => ({
    /*
      ✅ スプレッドマージのアルゴリズム：
      - 左から右へプロパティをコピーする
      - 同じキーがあれば右側（後）の値で上書きする（last write wins）
    */
    ...obj1,
    ...obj2,
});
/*
  ✅ 型パラメータの意味：

  - T：第1引数 obj1 の型
  - U extends T：第2引数 obj2 の型は T を満たす必要がある（少なくとも obj1 と同じ必須プロパティを持つ）

  これにより、例えば
    overMerge({ a: 3 }, { n: 6, m: 9 })
  のように、obj2 が a を持たないケースは型エラーになり得る。
  （obj2 は T を満たさないため）

  ✅ 返り値の型 T & U：
  - “T のプロパティ + U のプロパティ” を併せ持つ型として扱える。
  - 実装も 실제にプロパティを合体させているので直感に合う。

  ⚠️ ただしキー衝突時：
  - 型としては a が両方に存在していても、実体は obj2.a に上書きされる。
  - “両方の a を保持する” わけではない（履歴を持つマージではない）。
*/

// ------------------------------------------------------------
// 2) 呼び出し例：a が衝突するが obj2 の a が勝つ
// ------------------------------------------------------------
console.log(
    overMerge({ a: 1 }, { a: 4, b: 8 })
    /*
      ✅ 実行時の結果（概念）：
        { a: 4, b: 8 }
  
      - obj1 の a:1 は obj2 の a:4 によって上書きされる
      - b は obj2 にしかないので追加される
  
      ✅ 型としては：
      - T は { a: number }
      - U は { a: number; b: number } かつ T を満たすので OK
      - 戻り値は T & U で { a: number; b: number } 相当になる
    */

    // overMerge({ a: 3 }, { n: 6, m: 9 }),
    /*
      ❌ これは意図的にコメントアウトされている例：
      - obj1 の型 T は { a: number }
      - obj2 は { n: number; m: number } で a を持たない
      - U extends T を満たさないので、型チェックで拒否される（はず）
      → 「obj2 は obj1 の上位互換であるべき」という契約を enforce している
    */
);