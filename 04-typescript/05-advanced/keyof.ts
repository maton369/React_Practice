// ✅ このコードは TypeScript の
// - `typeof`（値から型を取る）
// - `keyof`（オブジェクト型のキー集合を union 型として取り出す）
// を組み合わせて、
// 「permissions オブジェクトのキーだけを許す型」を自動生成する例である。
//
// また、permissions の値は 2進数リテラル（0b...）で、権限ビットを表している。
// - r = 0b100（4）
// - w = 0b010（2）
// - x = 0b001（1）
// という “ビットフラグ” の典型パターンになっている。

{
    // ------------------------------------------------------------
    // 1) permissions：権限文字 → ビット値 の対応表（辞書）
    // ------------------------------------------------------------
    const permissions = {
        // ✅ 2進数リテラル
        // 0b100 は 4（読み取り権限）
        r: 0b100,

        // 0b010 は 2（書き込み権限）
        w: 0b010,

        // 0b001 は 1（実行権限）
        x: 0b001,
    };

    /*
      ✅ ビットフラグとしての意味（アルゴリズム）：
      - 権限の集合を 3bit の整数で表す
      - 複数権限を持つ場合は OR（|）で合成できる
  
      例（概念）：
        read + write = 0b100 | 0b010 = 0b110
        read + exec  = 0b100 | 0b001 = 0b101
  
      この辞書は “文字” から “ビット値” へ写像するテーブルになっている。
    */

    // ------------------------------------------------------------
    // 2) PermChar：permissions のキー集合を型として抽出
    // ------------------------------------------------------------
    type PermChar = keyof typeof permissions; // 'r' | 'w' | 'x'
    /*
      ここが TypeScript 的な核心：
  
      - typeof permissions
        => 「permissions という値の型」を取る（型クエリ）
           { r: number; w: number; x: number } に近い型になる
  
      - keyof (その型)
        => そのオブジェクト型が持つキー名を union 型として取り出す
           'r' | 'w' | 'x'
  
      結果として PermChar は「permissions に実在するキーだけ」を許す型になる。
      つまり、辞書のキーを追加/削除したら PermChar も自動で追従する。
    */

    // ------------------------------------------------------------
    // 3) 使用例：許されるキーは "r" | "w" | "x" のみ
    // ------------------------------------------------------------
    const readable: PermChar = "r";
    /*
      ✅ "r" は permissions のキーに存在するので OK
    */

    const writable: PermChar = 'z';
    /*
      ❌ "z" は permissions のキーに存在しないので TypeScript 的にエラーになるのが正しい挙動。
      - PermChar は 'r' | 'w' | 'x' に限定されている
      - 'z' はその集合に含まれない
  
      アルゴリズム的には：
      - “許可された文字集合” を辞書のキーから導出し、
        その集合外の入力を静的に遮断する、という設計になっている。
    */
}