// ✅ このコードは TypeScript の
// - `as const`（リテラル型として値を固定する）
// - `keyof typeof`（オブジェクトのキー集合を型として取り出す）
// - インデックスアクセス型 `(T)[K]`（「型TのキーKに対応する値の型」を取り出す）
// を組み合わせて、
// 「permissions のキー型（PermChar）」と「permissions の値型（PermNum）」を自動生成する例である。
//
// アルゴリズム的には：
// - permissions を “定数テーブル” として扱い、
//   そこから「許されるキー集合」と「許される値集合」を型レベルで抽出している。
// - これにより、テーブルを更新すれば型も追従し、手書きの union を減らせる。

{
    // ------------------------------------------------------------
    // 1) permissions：権限文字 → ビット値 の定数テーブル
    // ------------------------------------------------------------
    const permissions = {
        // ✅ `as const` により値を “数値リテラル型” に固定する
        // - r の型は 4（= 0b100）というリテラル型になる
        // - もし `as const` が無いと、型は普通に number に広がりやすい
        r: 0b100 as const,

        // w の型は 2（= 0b010）というリテラル型
        w: 0b010 as const,

        // x の型は 1（= 0b001）というリテラル型
        x: 0b001 as const,
    };

    /*
      ✅ `as const` の効果（型の精密化）：
      - 値の型が number ではなく、4 / 2 / 1 の “具体値そのもの” の型になる
      - この後で「値の union 型」を取り出したときに
          4 | 2 | 1
        のように “有限集合” として扱えるようになる
  
      ※ ここでは各プロパティに `as const` を付けているが、
         オブジェクト全体に `as const` を付ける書き方もある：
           const permissions = { r: 0b100, w: 0b010, x: 0b001 } as const;
         いずれも目的は “リテラル型で固定” すること。
    */

    // ------------------------------------------------------------
    // 2) PermChar：permissions のキー集合（'r' | 'w' | 'x'）
    // ------------------------------------------------------------
    type PermChar = keyof typeof permissions;
    /*
      - typeof permissions で値 permissions の “型” を取得
      - keyof でその型のキーを union として取得
      → PermChar は 'r' | 'w' | 'x' になる
    */

    // ------------------------------------------------------------
    // 3) PermNum：permissions の値集合（4 | 2 | 1）
    // ------------------------------------------------------------
    type PermNum = (typeof permissions)[PermChar];
    /*
      ここが TypeScript の型レベル “テーブル参照” の肝：
  
      - (typeof permissions) は型として { r: 4; w: 2; x: 1 } のようになる（as const のおかげ）
      - [PermChar] は “キーの union” でインデックスアクセスする
  
      つまり
        permissions['r' | 'w' | 'x']
      を型として評価するので、
        permissions['r'] | permissions['w'] | permissions['x']
      に相当し、最終的に
        4 | 2 | 1
      という union 型になる。
  
      ✅ `as const` が効いている理由：
      - もし値がただの number 型に広がっていたら、PermNum は number になってしまい、
        “有限集合としての値型” を取り出せない。
    */

    /*
      ✅ まとめ：
      - PermChar：許可された権限文字の集合（キー）
      - PermNum ：許可された権限ビット値の集合（値）
      を “単一の定数テーブル” から自動導出している。
    */
}