// ✅ このコードは JavaScript の `typeof`（実行時）と TypeScript の `typeof`（型取得）を並べて、
// 「同じキーワードでも用途が違う」ことを確認する例である。
//
// 重要ポイント：
// - JavaScript の typeof は “実行時に値の型名（文字列）を返す演算子”
// - TypeScript の typeof（型コンテキスト）は “値から型を取り出す（type query）”
// - 配列は JS の typeof だと "object" になる（配列専用の "array" にはならない）
// - `const arr = [1,2,3]` は型推論で number[] になるので、`typeof arr` は number[] 相当になる
// - その結果、NumArr は number[] となり、文字列配列は代入できず型エラーになる

// ------------------------------------------------------------
// 1) JavaScript の typeof（実行時）：値の種別を文字列で返す
// ------------------------------------------------------------
console.log(typeof 100);
/*
  ✅ 100 はプリミティブの number なので、実行時出力は "number"
*/

const arr = [1, 2, 3];
console.log(typeof arr);
/*
  ✅ 配列は内部的にはオブジェクトなので、実行時出力は "object"
  ⚠️ "array" とは出ない点が罠になりやすい。
  （配列判定は Array.isArray(arr) を使うのが一般的）
*/

// ------------------------------------------------------------
// 2) TypeScript の typeof（型コンテキスト）：値から “型” を抽出する
// ------------------------------------------------------------
type NumArr = typeof arr;
/*
  ✅ ここでの typeof は「型クエリ」。
  - “arr という値の型” を NumArr という名前にする。
  - arr は [1,2,3] の配列なので、型推論としては number[] になる。
  したがって NumArr は number[] 相当になる。
*/

// ------------------------------------------------------------
// 3) NumArr を使った代入：number[] ならOK
// ------------------------------------------------------------
const val: NumArr = [4, 5, 6];
/*
  ✅ val は NumArr = number[] なので、number の配列は代入可能
*/

// ------------------------------------------------------------
// 4) 型エラー例：string[] は NumArr（number[]）に代入できない
// ------------------------------------------------------------
const val2: NumArr = ["foo", "bar", "baz"];
/*
  ❌ ここは TypeScript 的に不正：
  - NumArr は number[] なのに、右辺は string[] だから互換がない。
  - つまり「arr と同じ型を再利用する」目的で typeof を使っているため、
    arr が number[] なら NumArr も number[] に固定される。

  ✅ 学び：
  - 実行時 typeof は “値の種別（文字列）”
  - 型の typeof は “値から型をコピーする”
  - 同じキーワードでも、実行時/型レベルで役割が完全に違う
*/