// ✅ このコードは JavaScript の
// - `in` 演算子（プロパティ存在チェック）
// - `for...in`（オブジェクトの列挙）
// と、TypeScript の
// - 文字列リテラル union をキーにした mapped type（型レベルの “辞書” 生成）
// を並べて比較する例である。
//
// 重要ポイント：
// - `'a' in obj` は「obj が a プロパティを持つか」を実行時に判定する
// - `for...in` はオブジェクトの “列挙可能（enumerable）なキー” を走査する
// - `FigMap = { [key in Fig]?: number }` は union の各要素をキーにしたオブジェクト型を生成する
// - `?` を付けると各キーが optional になり、存在しないキーも許容される（ただしキーは Fig に限定される）
// - `figMap.four = 4` は Fig に 'four' が含まれていないので TypeScript 的にはエラーになるのが通常

// ------------------------------------------------------------
// 1) JS: `in` 演算子と `for...in`
// ------------------------------------------------------------
const obj = { a: 1, b: 2, c: 3 };

// ✅ `'a' in obj` は「a というキーが obj の中に存在するか」を boolean で返す。
// - 自前のプロパティだけでなく、プロトタイプチェーン上のプロパティも true になり得る点に注意。
//   （例：'toString' in obj は true になり得る）
console.log('a' in obj);                      // true

// ✅ `for...in` は obj の “列挙可能なキー” を文字列として取り出してループする。
// - 出てくるのはキー（key）であり値ではない
// - 仕様上、列挙順序はおおむね挿入順に近いが、整数キーなどで例外があるので
//   厳密な順序依存は避けるのが安全
for (const key in obj) { console.log(key); }  // a b c

// ------------------------------------------------------------
// 2) TS: union をキーにした mapped type（FigMap）
// ------------------------------------------------------------

// ✅ Fig はキーの候補を有限集合に閉じる（'one'|'two'|'three' のみ）
type Fig = 'one' | 'two' | 'three';

// ✅ FigMap は “Fig の各要素をキーとして持つ辞書型” を型レベルで生成する。
// { [key in Fig]?: number } の意味：
// - key は Fig の各値（'one','two','three'）を順に取る型変数
// - その結果、生成される型は概念的に
//     { one?: number; two?: number; three?: number }
//   となる
//
// ✅ `?` が付いているので各プロパティは optional：
// - 省略可能（無いことも許される）
// - ただし「存在するなら number」という契約になる
type FigMap = { [key in Fig]?: number };

// ------------------------------------------------------------
// 3) FigMap の値を作る（キーは Fig の範囲内）
// ------------------------------------------------------------
const figMap: FigMap = {
    one: 1,
    two: 2,
    three: 3,
};
/*
  ✅ ここは OK：
  - one/two/three は Fig の要素で、FigMap の許可キー
  - 値は number なので要件を満たす
*/

// ------------------------------------------------------------
// 4) 許可されないキーの追加（通常は型エラー）
// ------------------------------------------------------------
figMap.four = 4;
/*
  ❌ ここは TypeScript 的には通常エラーになる：
  - FigMap のキー集合は 'one' | 'two' | 'three' に限定されている
  - 'four' はその集合に含まれないため “存在しないプロパティ” として拒否される

  ✅ 実行時の JavaScript と型の違い：
  - JS 実行時には、オブジェクトに新しいプロパティを生やすのは普通に可能
  - TS は「その操作を型安全として許すか」を静的に判断する
    → 許可キー以外の追加を防ぐことで、辞書のキー空間を管理する

  もし “任意のキーも許したい” なら、たとえば index signature を追加する設計になる：
    type FigMap = { [key in Fig]?: number } & { [k: string]: number };
  ただしそうすると “キー制約の厳密さ” は下がるので、用途に応じて選ぶ。
*/