// ✅ このコードは TypeScript の「文字列リテラル union 型」と、switch の「網羅性チェック（exhaustiveness check）」
// を組み合わせた例である。
// 友達の種類 friend を "Serval" | "Caracal" | "Cheetah" のどれかに限定し、
// switch で各ケースを処理しつつ、default で never を使って「取りこぼしがないか」をコンパイル時に検出する。

// ------------------------------------------------------------
// 1) greet(friend)：引数を “3種類の文字列” に限定する
// ------------------------------------------------------------
const greet = (friend: "Serval" | "Caracal" | "Cheetah") => {
    /*
      ✅ friend の型は文字列だが「任意の文字列」ではない。
      - "Serval"
      - "Caracal"
      - "Cheetah"
      のいずれかしか渡せない（コンパイル時に制約される）。
  
      これにより：
      - タイポ（"Serverl" など）をコンパイル時に弾ける
      - 分岐が有限集合に閉じるので、網羅性チェックができる
    */

    // ----------------------------------------------------------
    // 2) switch による分岐：入力値に応じて挨拶文を返す
    // ----------------------------------------------------------
    switch (friend) {
        case "Serval":
            // ✅ friend が "Serval" のときだけここに来る
            // この case 内では friend の型が "Serval" に絞り込まれている（型の絞り込み / narrowing）
            return `Hello, ${friend}!`;

        case "Caracal":
            // ✅ friend が "Caracal" の場合
            return `Hi, ${friend}!`;

        case "Cheetah":
            // ✅ friend が "Cheetah" の場合
            return `Hiya, ${friend}!`;

        // --------------------------------------------------------
        // 3) default + never による網羅性チェック
        // --------------------------------------------------------
        default: {
            /*
              ✅ ここは理論上 “到達不能” にしたい場所。
              friend の型は "Serval" | "Caracal" | "Cheetah" の3つしかないので、
              上の case をすべて書いていれば default は不要なはず。
      
              しかし、将来 union 型に新しい値（例："Jaguar"）を追加したのに
              switch の case 追加を忘れる、といった事故が起きる。
      
              そこで never を使う：
      
              - never は「到達し得ない値」を表す型
              - 全ケースを網羅していれば friend はここでは never になるはず
              - もし網羅できていない場合、friend は never ではないため、
                `const check: never = friend;` が型エラーになり、
                “case の追加忘れ” をコンパイル時に検出できる
      
              アルゴリズム的には：
              - union（有限集合）を分岐で “全列挙” し、
              - 取りこぼしがあれば型エラーで止める
              という “静的検証” を実現している。
            */
            const check: never = friend;

            // ※ check は使わなくてよい。ここに到達しないのが正しい状態。
            // return を書かなくても、到達不能なら問題ないという意図。
        }
    }
};

// ------------------------------------------------------------
// 4) 呼び出し：有効な文字列リテラルを渡す
// ------------------------------------------------------------
// ✅ greet("Serval") は型制約を満たすのでコンパイルOK
// 実行結果は "Hello, Serval!" が出力される。
console.log(greet("Serval"));

/*
  補足：
  - greet("Lion") のような値は型が合わないのでコンパイルエラーになる。
  - union に値を追加したら switch に case を追加しないと default の never 代入で検出できる。
*/