// ✅ このコードは TypeScript の「インデックスシグネチャ（index signature）」を使って、
// “キーが任意の文字列で、値は必ず number” という辞書（map）型を定義している例である。
//
// 重要ポイント：
// - interface Status { [parameter: string]: number; } は
//   「どんな文字列キーでもよいが、その値は number でなければならない」ことを表す
// - そのため myStatus に追加できるプロパティは、値が number のものに限られる
// - コメントアウトされた job: 'mage' は string なので型エラーになる（この型契約に違反）
// - 典型用途は「ステータス名が動的に増減する」ようなパラメータ辞書

// ------------------------------------------------------------
// 1) Status インターフェース：文字列キー → number 値の辞書型
// ------------------------------------------------------------
interface Status {
    // ✅ インデックスシグネチャ
    // parameter という変数名は “キー名の説明用” であって、実際のキーは任意の文字列になる。
    //
    // アルゴリズム的に言うと：
    // - オブジェクトに対して任意のキーでアクセスする（status[k]）ことを想定し、
    // - その戻り値の型が常に number である、と型システムに約束させる仕組み。
    [parameter: string]: number;
}

// ------------------------------------------------------------
// 2) myStatus の生成：Status の契約に合うオブジェクトを作る
// ------------------------------------------------------------
const myStatus: Status = {
    // ✅ 各プロパティの値はすべて number なので OK
    // “level” や “maxHP” などのキー名は自由に付けられる点がポイント。
    level: 22,
    experience: 3058,
    maxHP: 156,
    maxMP: 174,
    attack: 39,
    defense: 25,

    // job: 'mage',
    /*
      ✅ これを有効化すると TypeScript で型エラーになる（概念）
  
      理由：
      - Status は「どのキーの値も number である」ことを要求している
      - job の値 'mage' は string なので契約違反
  
      エラーのイメージ：
      Type 'string' is not assignable to type 'number'.
    */
};

// ------------------------------------------------------------
// 3) 出力：実行時にはただの JS オブジェクトとして表示される
// ------------------------------------------------------------
console.log(myStatus);

/*
  補足（型設計の意図）：
  - この Status は「決まった項目の集合」ではなく、「項目名が可変な辞書」を表す。
  - そのため myStatus["attack"] のような動的アクセスが想定される一方、
    存在しないキーにアクセスすると undefined になる可能性は実行時に残る。
    （型は number と言っているが、存在保証まではしていない）
  - “存在しないかもしれない” も型で表したい場合は
    [parameter: string]: number | undefined のようにする設計もあり得る。
*/