// ✅ このコードは TypeScript の「構造的型付け（structural typing）」を確認する例である。
// class で定義した Point 型に対して、
// - new Point() でクラスインスタンスを作るケース
// - “同じ形状（x と y を持つ）” のプレーンオブジェクトを Point として扱うケース
// を並べている。
// さらに interface Point3d extends Point によって、Point の形状を “拡張” した 3D 点を定義している。
//
// 重要ポイント：
// - TypeScript は「その型が class か interface か」よりも、「プロパティの形（構造）が合うか」を重視する
//   → Point 型は “x:number と y:number を持つ” なら OK になりやすい（名義型ではない）
// - ただし “クラスのメソッド” や “private フィールド” が関わると互換性が厳しくなる
// - interface が class を extends できるのは、「クラスのインスタンス型（公開メンバー）」を継承するため

// ------------------------------------------------------------
// 1) Point クラス：2D 座標 (x, y) を表す
// ------------------------------------------------------------
class Point {
    // ✅ x, y を number として持つ
    // = 0 で初期値を入れているので、new Point() した瞬間に x=0, y=0 の状態になる。
    x: number = 0;
    y: number = 0;

    // ※ constructor を書いていないので、暗黙の constructor() が使われる。
}

// ------------------------------------------------------------
// 2) pointA：クラスインスタンスとして生成
// ------------------------------------------------------------
const pointA = new Point();
/*
  ✅ new Point() の概念的な流れ：
  1) Point のインスタンス（オブジェクト）を生成
  2) フィールド初期化子 x=0, y=0 を適用
  3) （constructor があれば実行、今回は暗黙の空 constructor）
  → pointA は「Point のインスタンス」であり、プロトタイプは Point.prototype を指す
*/

// ------------------------------------------------------------
// 3) pointB：プレーンオブジェクトを Point 型として扱う
// ------------------------------------------------------------
const pointB: Point = { x: 2, y: 4 };
/*
  ✅ ここが構造的型付けの典型例：
  - 右辺は new Point() ではなく、ただのオブジェクトリテラル
  - それでも { x:number, y:number } という形が Point の要求と一致するため、Point 型として代入できる

  ⚠️ 重要な違い：
  - pointB は「Point のインスタンス」ではない（プロトタイプは Point.prototype ではない）
  - ただし “公開プロパティの形” は一致するので、TypeScript の型チェックは通る

  もし Point にメソッドが追加されると、そのメソッドも “形” に含まれるため、
  object literal 側がそのメソッドを持たない限り代入できなくなる。
*/

// ------------------------------------------------------------
// 4) Point3d：Point の形状を拡張して z を追加する
// ------------------------------------------------------------
interface Point3d extends Point {
    // ✅ Point（= x,y を持つ）の公開メンバーに加えて z:number を必須にする
    z: number;
}
/*
  ✅ interface が class を extends できる理由：
  - “Point クラスそのもの” を継承するのではなく、
    “Point のインスタンスが持つ公開メンバーの型” を継承するイメージ。
  - つまり Point3d は (x:number, y:number) + (z:number) の形状契約になる。
*/

// ------------------------------------------------------------
// 5) pointC：Point3d として成立するオブジェクト
// ------------------------------------------------------------
const pointC: Point3d = { x: 5, y: 5, z: 10 };
/*
  ✅ 代入条件（形状チェック）：
  - x:number がある
  - y:number がある
  - z:number がある
  → Point3d の契約を満たすので OK
*/

// ------------------------------------------------------------
// 6) 出力：実行時には “ただのオブジェクト” として表示される
// ------------------------------------------------------------
console.log(pointA);
console.log(pointB);
console.log(pointC);

/*
  補足（実行時の違いの観点）：
  - pointA は Point のインスタンスなので、プロトタイプチェーンが存在する
  - pointB と pointC はプレーンオブジェクト（リテラル）なので、プロトタイプは Object.prototype
  - ただし console.log で見えるのは主に “プロパティの中身” なので、見た目は似ることが多い
*/