// ✅ このコードは TypeScript での「関数の3つの書き方」を比較する例である。
// 1) 関数宣言（function declaration）
// 2) 関数式（function expression）
// 3) アロー関数式（arrow function expression）
//
// それぞれ “関数オブジェクトを作る” という点では同じだが、
// - 宣言の巻き上げ（hoisting）
// - this の束縛ルール（arrow は lexical this）
// - 型注釈の書き方・戻り値推論
// などが異なる。
//
// また、各ブロック { ... } はスコープを分けるために置かれている。
// これにより同じ名前 add を複数回定義しても衝突しない（ブロックスコープ）。

// ------------------------------------------------------------
// 1) function declaration statement（関数宣言）
// ------------------------------------------------------------
{
    // ✅ 関数宣言：function add(...) { ... }
    // - “宣言” として扱われ、スコープ内で巻き上げ（hoisting）されるのが特徴。
    //   （= ソースコード上で呼び出しが定義より前にあっても成立しやすい）
    //
    // TypeScript の型注釈：
    // - 引数 n, m は number
    // - 戻り値も number と明示している（return n + m は number になる）
    function add(n: number, m: number): number {
        // ✅ アルゴリズム（加算）：2つの数値を足して返す
        return n + m;
    }

    // ✅ 呼び出し：2 + 4 = 6
    console.log(add(2, 4));
}

// ------------------------------------------------------------
// 2) function keyword expression（関数式）
// ------------------------------------------------------------
{
    // ✅ 関数式：const add = function (...) { ... }
    // - 右辺で関数オブジェクトを “式として生成” し、変数 add に代入する。
    // - 関数宣言と違い、変数 add の宣言は hoist されても、
    //   代入（関数の実体のセット）は実行時まで行われない。
    //   つまり「代入前に呼ぶ」ことはできない（TDZ/undefined の問題になる）。
    //
    // TypeScript の型注釈：
    // - 引数と戻り値に number を明示
    const add = function (n: number, m: number): number {
        // ✅ アルゴリズムは同じ：n + m
        return n + m;
    };

    // ✅ 呼び出し：5 + 7 = 12
    console.log(add(5, 7));
}

// ------------------------------------------------------------
// 3) arrow function expression（アロー関数式）
// ------------------------------------------------------------
{
    // ✅ アロー関数：const add = (n, m) => ...
    // - 関数式の一種だが、書き方が簡潔で、this の扱いが大きく異なる。
    // - arrow は自分自身の this を持たず、外側スコープの this をそのまま捕まえる（lexical this）
    //   → コールバックで this がズレる問題を避けやすい。
    //
    // ここでは戻り値型 number を明示しているが、
    // `n + m` が number と推論できるので省略可能な場合も多い。
    const add = (n: number, m: number): number => n + m;

    // ✅ void 戻り値：値を返さず、副作用（console.log）だけを行う関数
    // - void は “返しても無視される” ではなく、基本的に値を返さない意図を示す
    // - ここでは明示的に return していない（= undefined を返す）  
    const hello = (): void => {
        console.log('Hello!');
    };

    // ✅ 呼び出し：8 + 1 = 9
    console.log(add(8, 1));

    // ✅ 呼び出し：Hello! を表示（戻り値は使わない）
    hello();
}

/*
  まとめ（比較の観点）：
  - 関数宣言：hoisting されやすい。名前付きでデバッグしやすい。
  - 関数式：変数に代入するので、関数を値として扱う設計（高階関数等）と相性が良い。
  - アロー関数：短く書ける + lexical this。コールバックで特に有利。

  どれも “数値を加算する” アルゴリズムは同じだが、
  「関数オブジェクトがいつ束縛されるか」「this の意味」「表現の簡潔さ」が違う。
*/