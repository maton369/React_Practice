// ✅ これは TypeScript の設定ファイル（tsconfig の一種）で、
// 主に Node 側（Vite の設定ファイル vite.config.ts）を型チェックする目的の構成である。
// いわゆる「アプリ本体用 tsconfig（DOMあり）」とは別に、
// “Node 用 tsconfig（DOMなし）” を用意しているパターンに近い。
//
// アルゴリズム的には：
// - tsc が解析する対象ファイル集合を `vite.config.ts` に絞り、
// - Node/ESNext 前提のモジュール解決（bundler mode）で import を解決し、
// - JS を出力せず（noEmit）型検査・静的検査だけを行う
// という “型検証パイプライン” を定義している。

{
  "compilerOptions": {
    // ------------------------------------------------------------
    // ビルド情報（incremental build のメタデータ置き場）
    // ------------------------------------------------------------
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    /*
      ✅ tsc のビルド/型チェックの差分管理用メタデータの保存先。
      - アプリ用とは別ファイルにすることで、構成（app/node）のキャッシュが混ざらない。
      - node_modules 配下に置くのは生成物をまとめる運用。
    */

    // ------------------------------------------------------------
    // 出力ターゲット（想定する JS の言語レベル）
    // ------------------------------------------------------------
    "target": "ES2022",
    /*
      ✅ Node 側の設定ファイルはモダン Node 実行を前提にしやすく、
      ES2022 までの構文/機能をそのまま使える想定にしている。
    */

    // ------------------------------------------------------------
    // 参照する標準ライブラリ（型定義）
    // ------------------------------------------------------------
    "lib": ["ES2023"],
    /*
      ✅ ここでは DOM を含めず、ES 標準のみを参照する。
      - Node の設定ファイル（vite.config.ts）は基本的にブラウザ API を使わないため。
      - ES2023 の型定義を参照することで、最新の標準機能の型が利用できる。

      ⚠️ Node 特有の型（process, __dirname など）が必要なら
         @types/node を導入した上で tsconfig 側で types を指定する運用もある。
    */

    // ------------------------------------------------------------
    // モジュール形式（import/export を ESNext として扱う）
    // ------------------------------------------------------------
    "module": "ESNext",
    /*
      ✅ Vite の設定も ESM ベースで書くことが多いので ESNext に寄せている。
      - バンドラが最終解決する前提。
    */

    // ------------------------------------------------------------
    // 依存ライブラリの型定義チェックを省略
    // ------------------------------------------------------------
    "skipLibCheck": true,
    /*
      ✅ 依存の型定義まで検証するとコストが増えるため省略して高速化する戦略。
      - 設定ファイル用途では特に実用性が高い。
    */

    /* Bundler mode */

    // ------------------------------------------------------------
    // モジュール解決戦略：バンドラ前提の解決規則
    // ------------------------------------------------------------
    "moduleResolution": "bundler",
    /*
      ✅ import 文字列 → 参照先 の解決を bundler 寄りにする。
      - Vite config は「バンドラ/ツールチェーン上で解決される import」を書くことがあるため、
        Node の素の解決規則より bundler 寄りが都合が良い。
    */

    // ------------------------------------------------------------
    // .ts 拡張子付き import を許可
    // ------------------------------------------------------------
    "allowImportingTsExtensions": true,
    /*
      ✅ `import x from './foo.ts'` のような書き方を許可する。
      - ツール設定ファイル周りで拡張子明示をする流儀と相性が良い。
    */

    // ------------------------------------------------------------
    // ファイル単位で独立してトランスパイルできることを要求
    // ------------------------------------------------------------
    "isolatedModules": true,
    /*
      ✅ Babel/SWC のような “ファイル単位変換” と矛盾しない書き方を強制する。
      - const enum など、TS の全体型情報がないと変換できない要素を避けやすい。
    */

    // ------------------------------------------------------------
    // モジュールとして扱う判定を強制
    // ------------------------------------------------------------
    "moduleDetection": "force",
    /*
      ✅ ファイルが script 扱いになってスコープ解釈が変わる等の揺れを避ける。
      - 設定ファイルでも import/export を前提に統一しやすい。
    */

    // ------------------------------------------------------------
    // JS を出力しない（型チェック専用）
    // ------------------------------------------------------------
    "noEmit": true,
    /*
      ✅ tsc を “型チェック・静的検査” のみの用途にする。
      - 実際の実行（Vite が読み込む設定）は別の経路で行われる前提。
      - app 用と同様、型チェックとビルドを分離する戦略。
    */

    /* Linting */

    // ------------------------------------------------------------
    // 厳格な型チェック（不確実性を許さない）
    // ------------------------------------------------------------
    "strict": true,
    /*
      ✅ null/undefined を含む曖昧さを排除し、明示を要求する方向。
      - 設定ファイルのミス（undefined を渡す等）も早期に検出しやすい。
    */

    // ------------------------------------------------------------
    // 未使用ローカル変数の検出
    // ------------------------------------------------------------
    "noUnusedLocals": true,
    /*
      ✅ 使われていない変数/関数を検出して、置き忘れや死コードを減らす。
    */

    // ------------------------------------------------------------
    // 未使用引数の検出
    // ------------------------------------------------------------
    "noUnusedParameters": true,
    /*
      ✅ 使われていない引数を検出する。
      - コールバックの型合わせ等で意図的に未使用が出る場合は
        `_arg` のように先頭 `_` を付けて運用で回避することが多い。
    */

    // ------------------------------------------------------------
    // switch の fallthrough（break 忘れ）を検出
    // ------------------------------------------------------------
    "noFallthroughCasesInSwitch": true,
    /*
      ✅ 制御フロー事故を防ぐ安全策。
    */

    // ------------------------------------------------------------
    // 副作用 import をより慎重に扱う（依存の暗黙性を減らす）
    // ------------------------------------------------------------
    "noUncheckedSideEffectImports": true
    /*
      ✅ import しただけで実行される副作用（ポリフィル、グローバル拡張等）を
      “管理すべきリスク” として検出しやすくする。
      - 設定ファイルは初期化順序の影響が出やすいので、特に相性が良い。
    */
  },

  // ------------------------------------------------------------
  // 型チェック対象ファイル集合：vite.config.ts のみに限定
  // ------------------------------------------------------------
  "include": ["vite.config.ts"]
  /*
    ✅ 解析対象を設定ファイルだけに絞る。
    アルゴリズム的には：
    - “Node 側（ツール設定）の型検査” をアプリ本体と分離し、
      不要な DOM 型や src 全体の解析を持ち込まない
    - その結果、チェックが軽くなりノイズも減る
  */
}