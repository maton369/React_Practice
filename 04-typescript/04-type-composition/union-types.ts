// ✅ このコードは TypeScript の interface と union 型（|）を使って、
// 「どちらか一方の形状を取り得る型」を作る例である。
// 特に、union に入っている型同士で
// - 同名プロパティの型が衝突するケース（foo: number vs foo: string）
// - optional と required の組み合わせ（bar?: string vs bar: string）
// - 片方にしか存在しないプロパティを含むケース（baz）
// を比較できるようになっている。
//
// 重要ポイント（アルゴリズム的観点）:
// - union 型 T = X | Y は「値が X の形状か、Y の形状のどちらかであればよい」
// - そのため、プロパティアクセスは “安全に確定できるものだけ” が許可されやすい
// - 同名プロパティが両側に存在しても型が一致しない場合、
//   そのプロパティは “どちらか分からない” ので、絞り込み（narrowing）が必要になる
// - optional/required の差は、「必ず存在する」と断言できるかに影響する

// ------------------------------------------------------------
// 1) インターフェース定義：それぞれ異なる形状を持つ
// ------------------------------------------------------------
interface A {
    // ✅ A では foo は number
    foo: number;

    // ✅ bar は optional（無いことも許される）
    // 型としては “string か undefined” を取り得る、と考えると理解しやすい
    bar?: string;
}

// ✅ B は foo が string（A と同名だが型が衝突）
interface B { foo: string; }

// ✅ C は bar が required string（A の bar?:string と “必須/任意” が衝突）
interface C { bar: string; }

// ✅ D は baz だけを持つ（A には存在しないプロパティ）
interface D { baz: boolean; }

// ------------------------------------------------------------
// 2) union 型の作成：A と別の型の “どちらか” を許す
// ------------------------------------------------------------

// ✅ AorB は「A または B」
// - A のとき foo:number、B のとき foo:string となり、同名プロパティ foo の型が一致しない。
// - そのため AorB 型の値 v に対して v.foo を読むと、型は number|string のように広がり得る。
// - 実際の利用では、実行時条件で A か B かを判定してから扱う（narrowing）が必要になりやすい。
type AorB = A | B;

// ✅ AorC は「A または C」
// - bar という同名プロパティを両方が持つが、A は optional、C は required。
// - union では “必ずある” とは言えない（A の場合は無い可能性がある）ため、
//   AorC の bar は「存在しないかもしれない」扱いになりやすい。
// - ただし「bar が存在したら string」という点は共通なので、
//   チェック（if (v.bar) ...）などで安全に扱える。
type AorC = A | C;

// ✅ AorD は「A または D」
// - A と D でプロパティ集合がほぼ別物（共通項が少ない）。
// - この union 型は「foo を持つかもしれないし、baz を持つかもしれない」状態になる。
// - したがって、どちらのプロパティもそのままでは安全に参照できず、
//   'in' 演算子などで “どっち側か” を絞り込むのが基本になる。
type AorD = A | D;

/*
  補足（設計的なコツ）：
  - union 型を実務で扱いやすくするには、判別用タグ（discriminant）を入れて
    “判別可能なユニオン” にするのが定石である。

    例（概念）：
      interface A { kind: 'A'; foo: number; ... }
      interface B { kind: 'B'; foo: string; ... }
      type AorB = A | B;

    こうすると switch(kind) で確実に絞り込めて、プロパティ型も安全に確定できる。
*/