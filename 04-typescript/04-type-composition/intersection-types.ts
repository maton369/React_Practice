// ✅ このコードは TypeScript の intersection 型（&）を使って、
// 「複数の型の要件を同時に満たす」型を作る例である。
// union（|）が “どちらかでOK” なのに対し、intersection（&）は “両方を満たす必要がある”。
//
// 重要ポイント（アルゴリズム的観点）:
// - T & U は「T の条件 + U の条件」を同時に満たす → プロパティ集合が合体するイメージ
// - 同名プロパティが衝突した場合、型が矛盾すると “never 方向” に追い込まれたり、代入不能になる
// - optional と required が交差すると、一般に required 側が勝ちやすい（必須要件が強い）
// - V & (T | U) は「V かつ (T または U)」で、分配則のように理解できる
//   = (V & T) | (V & U) に近い感覚（ただし詳細は TS の挙動に依る）

// ------------------------------------------------------------
// 1) 3つの interface：要件（プロパティ集合）を定義
// ------------------------------------------------------------
interface T { foo: number }
interface U { bar: string }
interface V {
    // ✅ foo は optional（無いことも許される）
    foo?: number;

    // ✅ baz は必須
    baz: boolean;
}

// ------------------------------------------------------------
// 2) TnU = T & U：foo と bar を両方持つ型
// ------------------------------------------------------------
// ✅ T は foo:number を要求
// ✅ U は bar:string を要求
//
// よって T & U は
//   { foo: number; bar: string }
// を満たす必要がある。
//
// アルゴリズム的には：
// - “要件の AND” であり、両方の制約を同時に課す。
// - プロパティ集合の合成（結合）として理解できる。
type TnU = T & U;

// ------------------------------------------------------------
// 3) TnV = T & V：V の optional foo と T の required foo が交差する
// ------------------------------------------------------------
// ✅ T は foo:number を “必須” で要求
// ✅ V は baz:boolean を必須、foo?:number を任意で要求
//
// 交差（&）では「両方の要件を満たす」必要があるため、
// - baz は必須（V の要件）
// - foo は必須（T の要件）
//
// となり、結果的に
//   { foo: number; baz: boolean }
// に近い型になる。
// optional 側（V.foo?）は「無くてもよい」だが、required 側（T.foo）が「必ず必要」なので、
// AND 条件では “必ず必要” が勝つイメージである。
type TnV = T & V;

// ------------------------------------------------------------
// 4) VnTorU = V & (T | U)：AND と OR の組み合わせ
// ------------------------------------------------------------
// ✅ これは「V であり、かつ (T か U のどちらか)」を満たす型。
// 論理式で書くと： V ∧ (T ∨ U)
//
// 直感的には分配して
//   (V & T) | (V & U)
// と同等の形として理解すると扱いやすい。
//
// - V & T は “baz:boolean を持ち、かつ foo:number を持つ” → { foo:number; baz:boolean; ... }
// - V & U は “baz:boolean を持ち、かつ bar:string を持つ” → { bar:string; baz:boolean; ... }
//
// つまり VnTorU の値は
// - baz は必ず必要（V の要件）
// - さらに foo を持つ（T 側に入った場合）か、bar を持つ（U 側に入った場合）
// のどちらかの形になる。
type VnTorU = V & (T | U);

/*
  補足（intersection の注意点）：
  - 同名プロパティが異なる型で衝突すると厄介になる。
    例：{ foo: number } & { foo: string } は foo が number かつ string を要求し、
        実質的に満たせない（never 的）状態になりやすい。
  - intersection は「要件を強くする（より厳密にする）」方向に働くので、
    型安全性は上がるが、代入可能な値は減る。
*/